// // // Default Freenove code + custom ui, music, weather basic mcp
// // #include <esp_log.h>
// // #include <driver/i2c_master.h>
// // #include <driver/spi_common.h>
// // #include <esp_lcd_panel_vendor.h>
// // #include <esp_lcd_panel_io.h>
// // #include <esp_lcd_panel_ops.h>
// // #include <wifi_station.h>
// // #include "application.h"
// // // #include "audio_codecs/no_audio_codec.h"
// // #include "audio/codecs/no_audio_codec.h"
// // // #include "audio_codecs/es8311_audio_codec.h"
// // #include "audio/codecs/es8311_audio_codec.h"
// // // #include "codecs/no_audio_codec.h"
// // // #include "codecs/es8311_audio_codec.h"
// // #include "button.h"
// // #include "display/lcd_display.h"
// // #include "led/single_led.h"
// // #include "system_reset.h"
// // #include "wifi_board.h"
// // #include "mcp_server.h"
// // #include "config.h"

// // #include "esp_lcd_ili9341.h"

// // #define TAG "FreenoveESP32S3Display"

// // LV_FONT_DECLARE(font_puhui_16_4);
// // LV_FONT_DECLARE(font_awesome_16_4);

// // class FreenoveESP32S3Display : public WifiBoard {
// //  private:
// //   Button boot_button_;
// //   LcdDisplay *display_;
// //   i2c_master_bus_handle_t codec_i2c_bus_;

// //   void InitializeSpi() {
// //     spi_bus_config_t buscfg = {};
// //     buscfg.mosi_io_num = DISPLAY_MOSI_PIN;
// //     buscfg.miso_io_num = DISPLAY_MIS0_PIN;
// //     buscfg.sclk_io_num = DISPLAY_SCK_PIN;
// //     buscfg.quadwp_io_num = GPIO_NUM_NC;
// //     buscfg.quadhd_io_num = GPIO_NUM_NC;
// //     buscfg.max_transfer_sz = DISPLAY_WIDTH * DISPLAY_HEIGHT * sizeof(uint16_t);
// //     ESP_ERROR_CHECK(spi_bus_initialize(LCD_SPI_HOST, &buscfg, SPI_DMA_CH_AUTO));
// //   }

// //   void InitializeLcdDisplay() {
// //     esp_lcd_panel_io_handle_t panel_io = nullptr;
// //     esp_lcd_panel_handle_t panel = nullptr;
// //     // 液晶屏控制IO初始化
// //     ESP_LOGD(TAG, "Install panel IO");
// //     esp_lcd_panel_io_spi_config_t io_config = {};
// //     io_config.cs_gpio_num = DISPLAY_CS_PIN;
// //     io_config.dc_gpio_num = DISPLAY_DC_PIN;
// //     io_config.spi_mode = DISPLAY_SPI_MODE;
// //     io_config.pclk_hz = DISPLAY_SPI_SCLK_HZ;
// //     io_config.trans_queue_depth = 10;
// //     io_config.lcd_cmd_bits = 8;
// //     io_config.lcd_param_bits = 8;
// //     ESP_ERROR_CHECK(esp_lcd_new_panel_io_spi(LCD_SPI_HOST, &io_config, &panel_io));
    
// //     // 初始化液晶屏驱动芯片
// //     ESP_LOGD(TAG, "Install LCD driver");
// //     esp_lcd_panel_dev_config_t panel_config = {};
// //     panel_config.reset_gpio_num = DISPLAY_RST_PIN;
// //     panel_config.rgb_ele_order = DISPLAY_RGB_ORDER;
// //     panel_config.bits_per_pixel = 16;
// //     ESP_ERROR_CHECK(esp_lcd_new_panel_ili9341(panel_io, &panel_config, &panel));
// //     ESP_LOGI(TAG, "Install LCD driver ILI9341");
// //     esp_lcd_panel_reset(panel);

// //     esp_lcd_panel_init(panel);
// //     esp_lcd_panel_invert_color(panel, DISPLAY_INVERT_COLOR);
// //     esp_lcd_panel_swap_xy(panel, DISPLAY_SWAP_XY);
// //     esp_lcd_panel_mirror(panel, DISPLAY_MIRROR_X, DISPLAY_MIRROR_Y);
// //     display_ = new SpiLcdDisplay(panel_io, panel, 
// //         DISPLAY_WIDTH, DISPLAY_HEIGHT, DISPLAY_OFFSET_X, DISPLAY_OFFSET_Y, 
// //         DISPLAY_MIRROR_X, DISPLAY_MIRROR_Y, DISPLAY_SWAP_XY
// //         // ,
// //         // {
// //         //     .text_font = &font_puhui_16_4,
// //         //     .icon_font = &font_awesome_16_4,
// //         //     .emoji_font = DISPLAY_HEIGHT >= 240 ? font_emoji_64_init() : font_emoji_32_init(),
// //         // }
// //       );
// //   }

// //   void InitializeI2c() {
// //       i2c_master_bus_config_t i2c_bus_cfg = {
// //           .i2c_port = AUDIO_CODEC_I2C_NUM,
// //           .sda_io_num = AUDIO_CODEC_I2C_SDA_PIN,
// //           .scl_io_num = AUDIO_CODEC_I2C_SCL_PIN,
// //           .clk_source = I2C_CLK_SRC_DEFAULT,
// //           .glitch_ignore_cnt = 7,
// //           .intr_priority = 0,
// //           .trans_queue_depth = 0,
// //           .flags = {
// //               .enable_internal_pullup = 1,
// //           },
// //       };
// //       ESP_ERROR_CHECK(i2c_new_master_bus(&i2c_bus_cfg, &codec_i2c_bus_));
// //   }

// //   void InitializeButtons() {
// //     boot_button_.OnClick([this]() {
// //       auto &app = Application::GetInstance();
// //       if (app.GetDeviceState() == kDeviceStateStarting &&
// //           !WifiStation::GetInstance().IsConnected()) {
// //         ResetWifiConfiguration();
// //       }
// //       app.ToggleChatState();
// //     });
// //   }

// //  public:
// //   FreenoveESP32S3Display(): boot_button_(BOOT_BUTTON_GPIO)
// //   {
// //     InitializeI2c();
// //     InitializeSpi();
// //     InitializeLcdDisplay();
// //     InitializeButtons();
// //     GetBacklight()->SetBrightness(100);
// //   }

// //   virtual Led *GetLed() override {
// //     static SingleLed led(BUILTIN_LED_GPIO);
// //     return &led;
// //   }

// //   virtual AudioCodec* GetAudioCodec() override {
// //     static Es8311AudioCodec audio_codec(codec_i2c_bus_, AUDIO_CODEC_I2C_NUM,
// //       AUDIO_INPUT_SAMPLE_RATE, AUDIO_OUTPUT_SAMPLE_RATE, AUDIO_I2S_GPIO_MCLK, AUDIO_I2S_GPIO_BCLK,
// //       AUDIO_I2S_GPIO_WS, AUDIO_I2S_GPIO_DOUT, AUDIO_I2S_GPIO_DIN, AUDIO_CODEC_PA_PIN,
// //       AUDIO_CODEC_ES8311_ADDR, true, true);
// //     return &audio_codec;
// //   }

// //   virtual Display *GetDisplay() override { return display_; }

// //   virtual Backlight *GetBacklight() override {
// //     static PwmBacklight backlight(DISPLAY_BACKLIGHT_PIN,
// //                                   DISPLAY_BACKLIGHT_OUTPUT_INVERT);
// //     return &backlight;
// //   }

// //   // Add this inside the "public:" section, usually after the constructor
// //   virtual void InitializeTools() override {
// //       auto& mcp_server = McpServer::GetInstance();

// //       // --- 1. Weather Tool ---
// //       mcp_server.AddTool("self.get_weather", 
// //           "Get the local weather information.", 
// //           PropertyList({
// //               Property("location", kPropertyTypeString, "The city name, e.g. New York")
// //           }), 
// //           [this](const PropertyList& properties) -> ReturnValue {
// //               std::string location = properties["location"].value<std::string>();
              
// //               // Notify the user via the chat bubble
// //               std::string msg = "Checking weather for " + location;
// //               GetDisplay()->SetChatMessage("assistant", msg.c_str());
              
// //               // In a real implementation, you might fetch data here.
// //               // For now, we return a success message so the AI knows it worked.
// //               return "Weather tool executed. (Placeholder implementation)"; 
// //           });

// //       // --- 2. Music Player Tool ---
// //       mcp_server.AddTool("self.music_player.play", 
// //           "Play music from a URL.", 
// //           PropertyList({
// //               Property("url", kPropertyTypeString, "The HTTP URL of the mp3/stream")
// //           }), 
// //           [this](const PropertyList& properties) -> ReturnValue {
// //               std::string url = properties["url"].value<std::string>();
// //               ESP_LOGI(TAG, "Playing music: %s", url.c_str());

// //               // Visual feedback
// //               GetDisplay()->SetChatMessage("assistant", "Playing music...");
// //               GetDisplay()->SetEmotion("music"); // Make sure you have a 'music.gif' in your assets!

// //               // Functional logic:
// //               // Since the default AudioService is optimized for voice chat, 
// //               // playing a music URL usually requires a dedicated player command.
// //               // If your codec supports it, you'd call it here.
// //               // For now, we confirm receipt.
// //               return "Music started.";
// //           });
// //   }

// // };

// // DECLARE_BOARD(FreenoveESP32S3Display);


// // custom ui + servo testing

// #include <driver/i2c_master.h>
// #include <driver/spi_common.h>

// #include "esp_lcd_panel_vendor.h"
// #include "esp_lcd_panel_io.h"
// #include "esp_lcd_panel_ops.h"
// #include "wifi_station.h"
// #include "application.h"
// #include "audio/codecs/es8311_audio_codec.h"
// #include "button.h"
// #include "display/lcd_display.h"
// #include "led/single_led.h"
// #include "system_reset.h"

// #include <esp_log.h>
// #include <driver/ledc.h>
// #include <freertos/FreeRTOS.h>
// #include <freertos/task.h>
// #include <math.h>

// // ... your other includes ...
// #include "wifi_board.h"
// #include "mcp_server.h"
// #include "config.h"
// #include "esp_lcd_ili9341.h"



// #define TAG "FreenoveBoard"

// // --- SERVO CONFIG ---
// #define SERVO_PAN_PIN       GPIO_NUM_2   // Changed from 14
// #define SERVO_TILT_PIN      GPIO_NUM_21
// #define SERVO_FREQ          50      // 50Hz for standard servos
// #define SERVO_TIMER         LEDC_TIMER_3  // Changed to timer 3 to avoid backlight conflict
// #define SERVO_RESOLUTION    LEDC_TIMER_14_BIT
// #define SERVO_CHANNEL_PAN   LEDC_CHANNEL_2   // Changed to channel 2
// #define SERVO_CHANNEL_TILT  LEDC_CHANNEL_3   // Changed to channel 3

// // PWM pulse widths in microseconds (based on actual servo specs)
// #define SERVO_MIN_PULSEWIDTH_US  350   // 0 degrees = 0.35ms
// #define SERVO_MAX_PULSEWIDTH_US  2270  // 180 degrees = 2.27ms
// #define SERVO_PERIOD_US          20000 // 20ms = 50Hz

// LV_FONT_DECLARE(font_puhui_16_4);
// LV_FONT_DECLARE(font_awesome_16_4);

// class FreenoveESP32S3Display : public WifiBoard {
//  private:
//   Button boot_button_;
//   LcdDisplay *display_;
//   i2c_master_bus_handle_t codec_i2c_bus_;

//   // Calculate duty cycle from angle (0-180 degrees)
//   uint32_t AngleToDuty(float angle) {
//       if (angle < 0.0f) angle = 0.0f;
//       if (angle > 180.0f) angle = 180.0f;
      
//       // Calculate pulse width in microseconds
//       uint32_t pulse_us = SERVO_MIN_PULSEWIDTH_US + 
//           (uint32_t)((SERVO_MAX_PULSEWIDTH_US - SERVO_MIN_PULSEWIDTH_US) * angle / 180.0f);
      
//       // Convert to duty cycle
//       // duty = (pulse_us / period_us) * max_duty
//       uint32_t max_duty = (1 << SERVO_RESOLUTION) - 1; // 2^14 - 1 for 14-bit
//       uint32_t duty = (pulse_us * max_duty) / SERVO_PERIOD_US;
      
//       return duty;
//   }

//   void InitializeServos() {
//       ESP_LOGI(TAG, "Initializing servos with direct LEDC...");
      
//       // Configure timer
//       ledc_timer_config_t timer_conf = {
//           .speed_mode = LEDC_LOW_SPEED_MODE,
//           .duty_resolution = SERVO_RESOLUTION,
//           .timer_num = SERVO_TIMER,
//           .freq_hz = SERVO_FREQ,
//           .clk_cfg = LEDC_AUTO_CLK
//       };
//       esp_err_t ret = ledc_timer_config(&timer_conf);
//       ESP_LOGI(TAG, "Timer config result: %s", esp_err_to_name(ret));
      
//       // Configure PAN channel
//       ledc_channel_config_t pan_conf = {
//           .gpio_num = SERVO_PAN_PIN,
//           .speed_mode = LEDC_LOW_SPEED_MODE,
//           .channel = SERVO_CHANNEL_PAN,
//           .intr_type = LEDC_INTR_DISABLE,
//           .timer_sel = SERVO_TIMER,
//           .duty = 0,
//           .hpoint = 0,
//           .flags = {.output_invert = 0}
//       };
//       ret = ledc_channel_config(&pan_conf);
//       ESP_LOGI(TAG, "Pan channel config result: %s", esp_err_to_name(ret));
      
//       // Configure TILT channel
//       ledc_channel_config_t tilt_conf = {
//           .gpio_num = SERVO_TILT_PIN,
//           .speed_mode = LEDC_LOW_SPEED_MODE,
//           .channel = SERVO_CHANNEL_TILT,
//           .intr_type = LEDC_INTR_DISABLE,
//           .timer_sel = SERVO_TIMER,
//           .duty = 0,
//           .hpoint = 0,
//           .flags = {.output_invert = 0}
//       };
//       ret = ledc_channel_config(&tilt_conf);
//       ESP_LOGI(TAG, "Tilt channel config result: %s", esp_err_to_name(ret));
      
//       // Set initial position
//       uint32_t center_duty = AngleToDuty(90.0f);
//       ESP_LOGI(TAG, "Center position duty cycle: %lu (out of %lu)", 
//                center_duty, (1 << SERVO_RESOLUTION) - 1);
      
//       SetServoAngle(SERVO_CHANNEL_PAN, 90.0f);
//       SetServoAngle(SERVO_CHANNEL_TILT, 90.0f);
      
//       ESP_LOGI(TAG, "Servos initialized on pins %d (pan) & %d (tilt)", 
//                SERVO_PAN_PIN, SERVO_TILT_PIN);
//   }

//   void SetServoAngle(ledc_channel_t channel, float angle) {
//       uint32_t duty = AngleToDuty(angle);
//       ESP_LOGI(TAG, "Setting channel %d to angle %.1f° (duty: %lu)", 
//                channel, angle, duty);
//       ledc_set_duty(LEDC_LOW_SPEED_MODE, channel, duty);
//       ledc_update_duty(LEDC_LOW_SPEED_MODE, channel);
//   }

//   void PerformGesture(const std::string& gesture) {
//       ESP_LOGI(TAG, "Gesture: %s", gesture.c_str());
      
//       if (gesture == "nod") { 
//           for(int i=0; i<3; i++) {
//               SetServoAngle(SERVO_CHANNEL_TILT, 110.0f); 
//               vTaskDelay(pdMS_TO_TICKS(150));
//               SetServoAngle(SERVO_CHANNEL_TILT, 70.0f);  
//               vTaskDelay(pdMS_TO_TICKS(150));
//           }
//           SetServoAngle(SERVO_CHANNEL_TILT, 90.0f);
//       } 
//       else if (gesture == "shake") { 
//           for(int i=0; i<3; i++) {
//               SetServoAngle(SERVO_CHANNEL_PAN, 120.0f); 
//               vTaskDelay(pdMS_TO_TICKS(150));
//               SetServoAngle(SERVO_CHANNEL_PAN, 60.0f);  
//               vTaskDelay(pdMS_TO_TICKS(150));
//           }
//           SetServoAngle(SERVO_CHANNEL_PAN, 90.0f);
//       }
//       else if (gesture == "dance") {
//           uint32_t start_time = esp_log_timestamp();
//           while (esp_log_timestamp() - start_time < 5000) {
//               float t = (esp_log_timestamp() - start_time) / 400.0;
//               float a1 = (sin(t) * 30) + 90;
//               float a2 = (cos(t) * 30) + 90;
//               SetServoAngle(SERVO_CHANNEL_PAN, a1);
//               SetServoAngle(SERVO_CHANNEL_TILT, a2);
//               vTaskDelay(pdMS_TO_TICKS(20));
//           }
//           SetServoAngle(SERVO_CHANNEL_PAN, 90.0f);
//           SetServoAngle(SERVO_CHANNEL_TILT, 90.0f);
//       }
//   }

//   void InitializeSpi() {
//     spi_bus_config_t buscfg = {};
//     buscfg.mosi_io_num = DISPLAY_MOSI_PIN;
//     buscfg.miso_io_num = DISPLAY_MIS0_PIN;
//     buscfg.sclk_io_num = DISPLAY_SCK_PIN;
//     buscfg.quadwp_io_num = GPIO_NUM_NC;
//     buscfg.quadhd_io_num = GPIO_NUM_NC;
//     buscfg.max_transfer_sz = DISPLAY_WIDTH * DISPLAY_HEIGHT * sizeof(uint16_t);
//     ESP_ERROR_CHECK(spi_bus_initialize(LCD_SPI_HOST, &buscfg, SPI_DMA_CH_AUTO));
//   }

//   void InitializeLcdDisplay() {
//     esp_lcd_panel_io_handle_t panel_io = nullptr;
//     esp_lcd_panel_handle_t panel = nullptr;

//     ESP_LOGD(TAG, "Install panel IO");
//     esp_lcd_panel_io_spi_config_t io_config = {};
//     io_config.cs_gpio_num = DISPLAY_CS_PIN;
//     io_config.dc_gpio_num = DISPLAY_DC_PIN;
//     io_config.spi_mode = DISPLAY_SPI_MODE;
//     io_config.pclk_hz = DISPLAY_SPI_SCLK_HZ;
//     io_config.trans_queue_depth = 10;
//     io_config.lcd_cmd_bits = 8;
//     io_config.lcd_param_bits = 8;
//     ESP_ERROR_CHECK(esp_lcd_new_panel_io_spi(LCD_SPI_HOST, &io_config, &panel_io));
    
//     ESP_LOGD(TAG, "Install LCD driver");
//     esp_lcd_panel_dev_config_t panel_config = {};
//     panel_config.reset_gpio_num = DISPLAY_RST_PIN;
//     panel_config.rgb_ele_order = DISPLAY_RGB_ORDER;
//     panel_config.bits_per_pixel = 16;
//     ESP_ERROR_CHECK(esp_lcd_new_panel_ili9341(panel_io, &panel_config, &panel));
//     esp_lcd_panel_reset(panel);

//     esp_lcd_panel_init(panel);
//     esp_lcd_panel_invert_color(panel, DISPLAY_INVERT_COLOR);
//     esp_lcd_panel_swap_xy(panel, DISPLAY_SWAP_XY);
//     esp_lcd_panel_mirror(panel, DISPLAY_MIRROR_X, DISPLAY_MIRROR_Y);
    
//     display_ = new SpiLcdDisplay(panel_io, panel, 
//         DISPLAY_WIDTH, DISPLAY_HEIGHT, DISPLAY_OFFSET_X, DISPLAY_OFFSET_Y, 
//         DISPLAY_MIRROR_X, DISPLAY_MIRROR_Y, DISPLAY_SWAP_XY);
//   }

//   void InitializeI2c() {
//       i2c_master_bus_config_t i2c_bus_cfg = {
//           .i2c_port = AUDIO_CODEC_I2C_NUM,
//           .sda_io_num = AUDIO_CODEC_I2C_SDA_PIN,
//           .scl_io_num = AUDIO_CODEC_I2C_SCL_PIN,
//           .clk_source = I2C_CLK_SRC_DEFAULT,
//           .glitch_ignore_cnt = 7,
//           .intr_priority = 0,
//           .trans_queue_depth = 0,
//           .flags = { .enable_internal_pullup = 1 },
//       };
//       ESP_ERROR_CHECK(i2c_new_master_bus(&i2c_bus_cfg, &codec_i2c_bus_));
//   }

//   void InitializeButtons() {
//     boot_button_.OnClick([this]() {
//       auto &app = Application::GetInstance();
//       if (app.GetDeviceState() == kDeviceStateStarting &&
//           !WifiStation::GetInstance().IsConnected()) {
//         ResetWifiConfiguration();
//       }
//       app.ToggleChatState();
//     });
//   }

//   static void ServoTestTask(void* param) {
//       FreenoveESP32S3Display* board = (FreenoveESP32S3Display*)param;
//       ESP_LOGI(TAG, "Servo test task started - continuous wiggling");
      
//       while(true) {
//           // Sweep pan left to right
//           for(int angle = 45; angle <= 135; angle += 5) {
//               board->SetServoAngle(SERVO_CHANNEL_PAN, (float)angle);
//               vTaskDelay(pdMS_TO_TICKS(50));
//           }
//           for(int angle = 135; angle >= 45; angle -= 5) {
//               board->SetServoAngle(SERVO_CHANNEL_PAN, (float)angle);
//               vTaskDelay(pdMS_TO_TICKS(50));
//           }
          
//           // Sweep tilt up to down
//           for(int angle = 60; angle <= 120; angle += 5) {
//               board->SetServoAngle(SERVO_CHANNEL_TILT, (float)angle);
//               vTaskDelay(pdMS_TO_TICKS(50));
//           }
//           for(int angle = 120; angle >= 60; angle -= 5) {
//               board->SetServoAngle(SERVO_CHANNEL_TILT, (float)angle);
//               vTaskDelay(pdMS_TO_TICKS(50));
//           }
          
//           // Both together - figure 8 pattern
//           for(int i = 0; i < 100; i++) {
//               float t = i / 10.0f;
//               float pan = 90 + 30 * sin(t);
//               float tilt = 90 + 20 * cos(t * 1.5);
//               board->SetServoAngle(SERVO_CHANNEL_PAN, pan);
//               board->SetServoAngle(SERVO_CHANNEL_TILT, tilt);
//               vTaskDelay(pdMS_TO_TICKS(50));
//           }
//       }
//   }

//  public:
//   FreenoveESP32S3Display(): boot_button_(BOOT_BUTTON_GPIO)
//   {
//     InitializeI2c();
//     InitializeSpi();
//     InitializeLcdDisplay();
//     InitializeButtons();
//     InitializeServos();

//     // Startup wiggle test
//     ESP_LOGW(TAG, "--- STARTUP WIGGLE ---");
//     SetServoAngle(SERVO_CHANNEL_PAN, 45.0f);
//     vTaskDelay(pdMS_TO_TICKS(500));
//     SetServoAngle(SERVO_CHANNEL_PAN, 135.0f);
//     vTaskDelay(pdMS_TO_TICKS(500));
//     SetServoAngle(SERVO_CHANNEL_PAN, 90.0f);
//     SetServoAngle(SERVO_CHANNEL_TILT, 90.0f);
//     ESP_LOGW(TAG, "--- WIGGLE DONE ---");

//     InitializeTools(); 
//     GetBacklight()->SetBrightness(100);
    
//     // Start continuous servo test task
//     xTaskCreate(ServoTestTask, "servo_test", 4096, this, 5, NULL);
//     ESP_LOGW(TAG, "Continuous servo test enabled - motors will keep wiggling");
//   }

//   void InitializeTools() {
//       auto& mcp_server = McpServer::GetInstance();

//       mcp_server.AddTool("self.head.gesture", 
//           "Perform a physical head gesture.", 
//           PropertyList({
//               Property("type", kPropertyTypeString, "nod, shake, dance")
//           }), 
//           [this](const PropertyList& properties) -> ReturnValue {
//               std::string type = properties["type"].value<std::string>();
//               if (type == "nod") GetDisplay()->SetEmotion("happy");
//               else if (type == "shake") GetDisplay()->SetEmotion("sad");
//               else if (type == "dance") GetDisplay()->SetEmotion("music");
//               PerformGesture(type);
//               return "Gesture done."; 
//           });

//       mcp_server.AddTool("self.head.look_at", 
//           "Rotate head.", 
//           PropertyList({
//               Property("direction", kPropertyTypeString, "center, up, down, left, right")
//           }), 
//           [this](const PropertyList& properties) -> ReturnValue {
//               std::string dir = properties["direction"].value<std::string>();
//               if (dir == "center") { 
//                   SetServoAngle(SERVO_CHANNEL_PAN, 90.0f); 
//                   SetServoAngle(SERVO_CHANNEL_TILT, 90.0f); 
//               }
//               else if (dir == "left") SetServoAngle(SERVO_CHANNEL_PAN, 135.0f);
//               else if (dir == "right") SetServoAngle(SERVO_CHANNEL_PAN, 45.0f);
//               else if (dir == "up") SetServoAngle(SERVO_CHANNEL_TILT, 120.0f);
//               else if (dir == "down") SetServoAngle(SERVO_CHANNEL_TILT, 60.0f);
//               return "Head moved."; 
//           });

//       mcp_server.AddTool("self.get_weather", 
//         "Get local weather.", 
//         PropertyList({ Property("location", kPropertyTypeString, "City name") }), 
//         [this](const PropertyList& properties) -> ReturnValue {
//             std::string location = properties["location"].value<std::string>();
//             GetDisplay()->SetChatMessage("assistant", ("Checking weather for " + location).c_str());
//             return "Weather tool executed."; 
//         });

//       mcp_server.AddTool("self.music_player.play", 
//         "Play music URL.", 
//         PropertyList({ Property("url", kPropertyTypeString, "URL") }), 
//         [this](const PropertyList& properties) -> ReturnValue {
//             GetDisplay()->SetChatMessage("assistant", "Playing music...");
//             GetDisplay()->SetEmotion("music");
//             return "Music started.";
//         });
//   }
  
//   virtual void TriggerGesture(const std::string& gesture) {
//       PerformGesture(gesture);
//   }

//   virtual Led *GetLed() override { 
//       static SingleLed led(BUILTIN_LED_GPIO); 
//       return &led; 
//   }
  
//   virtual AudioCodec* GetAudioCodec() override {
//     static Es8311AudioCodec audio_codec(codec_i2c_bus_, AUDIO_CODEC_I2C_NUM,
//       AUDIO_INPUT_SAMPLE_RATE, AUDIO_OUTPUT_SAMPLE_RATE, AUDIO_I2S_GPIO_MCLK, 
//       AUDIO_I2S_GPIO_BCLK, AUDIO_I2S_GPIO_WS, AUDIO_I2S_GPIO_DOUT, 
//       AUDIO_I2S_GPIO_DIN, AUDIO_CODEC_PA_PIN, AUDIO_CODEC_ES8311_ADDR, 
//       true, true);
//     return &audio_codec;
//   }
  
//   virtual Display *GetDisplay() override { 
//       return display_; 
//   }
  
//   virtual Backlight *GetBacklight() override { 
//       static PwmBacklight b(DISPLAY_BACKLIGHT_PIN, DISPLAY_BACKLIGHT_OUTPUT_INVERT); 
//       return &b; 
//   }
// };

// DECLARE_BOARD(FreenoveESP32S3Display);

// mcp motor control claude
// #include <driver/i2c_master.h>
// #include <driver/spi_common.h>

// #include "esp_lcd_panel_vendor.h"
// #include "esp_lcd_panel_io.h"
// #include "esp_lcd_panel_ops.h"
// #include "wifi_station.h"
// #include "application.h"
// #include "audio/codecs/es8311_audio_codec.h"
// #include "button.h"
// #include "display/lcd_display.h"
// #include "led/single_led.h"
// #include "system_reset.h"

// #include <esp_log.h>
// #include <driver/ledc.h>
// #include <freertos/FreeRTOS.h>
// #include <freertos/task.h>
// #include <math.h>

// // ... your other includes ...
// #include "wifi_board.h"
// #include "mcp_server.h"
// #include "config.h"
// #include "esp_lcd_ili9341.h"



// #define TAG "FreenoveBoard"

// // --- SERVO CONFIG ---
// #define SERVO_PAN_PIN       GPIO_NUM_2   // Changed from 14
// #define SERVO_TILT_PIN      GPIO_NUM_21
// #define SERVO_FREQ          50      // 50Hz for standard servos
// #define SERVO_TIMER         LEDC_TIMER_3  // Changed to timer 3 to avoid backlight conflict
// #define SERVO_RESOLUTION    LEDC_TIMER_14_BIT
// #define SERVO_CHANNEL_PAN   LEDC_CHANNEL_2   // Changed to channel 2
// #define SERVO_CHANNEL_TILT  LEDC_CHANNEL_3   // Changed to channel 3

// // PWM pulse widths in microseconds (based on actual servo specs)
// #define SERVO_MIN_PULSEWIDTH_US  350   // 0 degrees = 0.35ms
// #define SERVO_MAX_PULSEWIDTH_US  2270  // 180 degrees = 2.27ms
// #define SERVO_PERIOD_US          20000 // 20ms = 50Hz

// LV_FONT_DECLARE(font_puhui_16_4);
// LV_FONT_DECLARE(font_awesome_16_4);

// class FreenoveESP32S3Display : public WifiBoard {
//  private:
//   Button boot_button_;
//   LcdDisplay *display_;
//   i2c_master_bus_handle_t codec_i2c_bus_;

//   // Calculate duty cycle from angle (0-180 degrees)
//   uint32_t AngleToDuty(float angle) {
//       if (angle < 0.0f) angle = 0.0f;
//       if (angle > 180.0f) angle = 180.0f;
      
//       // Calculate pulse width in microseconds
//       uint32_t pulse_us = SERVO_MIN_PULSEWIDTH_US + 
//           (uint32_t)((SERVO_MAX_PULSEWIDTH_US - SERVO_MIN_PULSEWIDTH_US) * angle / 180.0f);
      
//       // Convert to duty cycle
//       // duty = (pulse_us / period_us) * max_duty
//       uint32_t max_duty = (1 << SERVO_RESOLUTION) - 1; // 2^14 - 1 for 14-bit
//       uint32_t duty = (pulse_us * max_duty) / SERVO_PERIOD_US;
      
//       return duty;
//   }

//   void InitializeServos() {
//       ESP_LOGI(TAG, "Initializing servos with direct LEDC...");
      
//       // Configure timer
//       ledc_timer_config_t timer_conf = {
//           .speed_mode = LEDC_LOW_SPEED_MODE,
//           .duty_resolution = SERVO_RESOLUTION,
//           .timer_num = SERVO_TIMER,
//           .freq_hz = SERVO_FREQ,
//           .clk_cfg = LEDC_AUTO_CLK
//       };
//       esp_err_t ret = ledc_timer_config(&timer_conf);
//       ESP_LOGI(TAG, "Timer config result: %s", esp_err_to_name(ret));
      
//       // Configure PAN channel
//       ledc_channel_config_t pan_conf = {
//           .gpio_num = SERVO_PAN_PIN,
//           .speed_mode = LEDC_LOW_SPEED_MODE,
//           .channel = SERVO_CHANNEL_PAN,
//           .intr_type = LEDC_INTR_DISABLE,
//           .timer_sel = SERVO_TIMER,
//           .duty = 0,
//           .hpoint = 0,
//           .flags = {.output_invert = 0}
//       };
//       ret = ledc_channel_config(&pan_conf);
//       ESP_LOGI(TAG, "Pan channel config result: %s", esp_err_to_name(ret));
      
//       // Configure TILT channel
//       ledc_channel_config_t tilt_conf = {
//           .gpio_num = SERVO_TILT_PIN,
//           .speed_mode = LEDC_LOW_SPEED_MODE,
//           .channel = SERVO_CHANNEL_TILT,
//           .intr_type = LEDC_INTR_DISABLE,
//           .timer_sel = SERVO_TIMER,
//           .duty = 0,
//           .hpoint = 0,
//           .flags = {.output_invert = 0}
//       };
//       ret = ledc_channel_config(&tilt_conf);
//       ESP_LOGI(TAG, "Tilt channel config result: %s", esp_err_to_name(ret));
      
//       // Set initial position
//       uint32_t center_duty = AngleToDuty(90.0f);
//       ESP_LOGI(TAG, "Center position duty cycle: %lu (out of %lu)", 
//                center_duty, (1 << SERVO_RESOLUTION) - 1);
      
//       SetServoAngle(SERVO_CHANNEL_PAN, 90.0f);
//       SetServoAngle(SERVO_CHANNEL_TILT, 90.0f);
      
//       ESP_LOGI(TAG, "Servos initialized on pins %d (pan) & %d (tilt)", 
//                SERVO_PAN_PIN, SERVO_TILT_PIN);
//   }

//   void SetServoAngle(ledc_channel_t channel, float angle) {
//       uint32_t duty = AngleToDuty(angle);
//       ESP_LOGI(TAG, "Setting channel %d to angle %.1f° (duty: %lu)", 
//                channel, angle, duty);
//       ledc_set_duty(LEDC_LOW_SPEED_MODE, channel, duty);
//       ledc_update_duty(LEDC_LOW_SPEED_MODE, channel);
//   }

//   void PerformGesture(const std::string& gesture) {
//       ESP_LOGI(TAG, "Gesture: %s", gesture.c_str());
      
//       if (gesture == "nod") { 
//           // Nod yes - up and down
//           for(int i=0; i<3; i++) {
//               SetServoAngle(SERVO_CHANNEL_TILT, 110.0f); 
//               vTaskDelay(pdMS_TO_TICKS(150));
//               SetServoAngle(SERVO_CHANNEL_TILT, 70.0f);  
//               vTaskDelay(pdMS_TO_TICKS(150));
//           }
//           SetServoAngle(SERVO_CHANNEL_TILT, 90.0f);
//       } 
//       else if (gesture == "shake") { 
//           // Shake no - left and right
//           for(int i=0; i<3; i++) {
//               SetServoAngle(SERVO_CHANNEL_PAN, 120.0f); 
//               vTaskDelay(pdMS_TO_TICKS(150));
//               SetServoAngle(SERVO_CHANNEL_PAN, 60.0f);  
//               vTaskDelay(pdMS_TO_TICKS(150));
//           }
//           SetServoAngle(SERVO_CHANNEL_PAN, 90.0f);
//       }
//       else if (gesture == "dance") {
//           // Excited circular motion
//           uint32_t start_time = esp_log_timestamp();
//           while (esp_log_timestamp() - start_time < 5000) {
//               float t = (esp_log_timestamp() - start_time) / 400.0;
//               float a1 = (sin(t) * 30) + 90;
//               float a2 = (cos(t) * 30) + 90;
//               SetServoAngle(SERVO_CHANNEL_PAN, a1);
//               SetServoAngle(SERVO_CHANNEL_TILT, a2);
//               vTaskDelay(pdMS_TO_TICKS(20));
//           }
//           SetServoAngle(SERVO_CHANNEL_PAN, 90.0f);
//           SetServoAngle(SERVO_CHANNEL_TILT, 90.0f);
//       }
//       else if (gesture == "tilt") {
//           // Curious head tilt
//           SetServoAngle(SERVO_CHANNEL_PAN, 110.0f);
//           vTaskDelay(pdMS_TO_TICKS(300));
//           SetServoAngle(SERVO_CHANNEL_TILT, 100.0f);
//           vTaskDelay(pdMS_TO_TICKS(500));
//           SetServoAngle(SERVO_CHANNEL_PAN, 90.0f);
//           SetServoAngle(SERVO_CHANNEL_TILT, 90.0f);
//       }
//       else if (gesture == "wiggle") {
//           // Playful wiggle
//           for(int i=0; i<4; i++) {
//               SetServoAngle(SERVO_CHANNEL_PAN, 100.0f);
//               vTaskDelay(pdMS_TO_TICKS(100));
//               SetServoAngle(SERVO_CHANNEL_PAN, 80.0f);
//               vTaskDelay(pdMS_TO_TICKS(100));
//           }
//           SetServoAngle(SERVO_CHANNEL_PAN, 90.0f);
//       }
//   }

//   void InitializeSpi() {
//     spi_bus_config_t buscfg = {};
//     buscfg.mosi_io_num = DISPLAY_MOSI_PIN;
//     buscfg.miso_io_num = DISPLAY_MIS0_PIN;
//     buscfg.sclk_io_num = DISPLAY_SCK_PIN;
//     buscfg.quadwp_io_num = GPIO_NUM_NC;
//     buscfg.quadhd_io_num = GPIO_NUM_NC;
//     buscfg.max_transfer_sz = DISPLAY_WIDTH * DISPLAY_HEIGHT * sizeof(uint16_t);
//     ESP_ERROR_CHECK(spi_bus_initialize(LCD_SPI_HOST, &buscfg, SPI_DMA_CH_AUTO));
//   }

//   void InitializeLcdDisplay() {
//     esp_lcd_panel_io_handle_t panel_io = nullptr;
//     esp_lcd_panel_handle_t panel = nullptr;

//     ESP_LOGD(TAG, "Install panel IO");
//     esp_lcd_panel_io_spi_config_t io_config = {};
//     io_config.cs_gpio_num = DISPLAY_CS_PIN;
//     io_config.dc_gpio_num = DISPLAY_DC_PIN;
//     io_config.spi_mode = DISPLAY_SPI_MODE;
//     io_config.pclk_hz = DISPLAY_SPI_SCLK_HZ;
//     io_config.trans_queue_depth = 10;
//     io_config.lcd_cmd_bits = 8;
//     io_config.lcd_param_bits = 8;
//     ESP_ERROR_CHECK(esp_lcd_new_panel_io_spi(LCD_SPI_HOST, &io_config, &panel_io));
    
//     ESP_LOGD(TAG, "Install LCD driver");
//     esp_lcd_panel_dev_config_t panel_config = {};
//     panel_config.reset_gpio_num = DISPLAY_RST_PIN;
//     panel_config.rgb_ele_order = DISPLAY_RGB_ORDER;
//     panel_config.bits_per_pixel = 16;
//     ESP_ERROR_CHECK(esp_lcd_new_panel_ili9341(panel_io, &panel_config, &panel));
//     esp_lcd_panel_reset(panel);

//     esp_lcd_panel_init(panel);
//     esp_lcd_panel_invert_color(panel, DISPLAY_INVERT_COLOR);
//     esp_lcd_panel_swap_xy(panel, DISPLAY_SWAP_XY);
//     esp_lcd_panel_mirror(panel, DISPLAY_MIRROR_X, DISPLAY_MIRROR_Y);
    
//     display_ = new SpiLcdDisplay(panel_io, panel, 
//         DISPLAY_WIDTH, DISPLAY_HEIGHT, DISPLAY_OFFSET_X, DISPLAY_OFFSET_Y, 
//         DISPLAY_MIRROR_X, DISPLAY_MIRROR_Y, DISPLAY_SWAP_XY);
//   }

//   void InitializeI2c() {
//       i2c_master_bus_config_t i2c_bus_cfg = {
//           .i2c_port = AUDIO_CODEC_I2C_NUM,
//           .sda_io_num = AUDIO_CODEC_I2C_SDA_PIN,
//           .scl_io_num = AUDIO_CODEC_I2C_SCL_PIN,
//           .clk_source = I2C_CLK_SRC_DEFAULT,
//           .glitch_ignore_cnt = 7,
//           .intr_priority = 0,
//           .trans_queue_depth = 0,
//           .flags = { .enable_internal_pullup = 1 },
//       };
//       ESP_ERROR_CHECK(i2c_new_master_bus(&i2c_bus_cfg, &codec_i2c_bus_));
//   }

//   void InitializeButtons() {
//     boot_button_.OnClick([this]() {
//       auto &app = Application::GetInstance();
//       if (app.GetDeviceState() == kDeviceStateStarting &&
//           !WifiStation::GetInstance().IsConnected()) {
//         ResetWifiConfiguration();
//       }
//       app.ToggleChatState();
//     });
//   }

//   static void ServoTestTask(void* param) {
//       FreenoveESP32S3Display* board = (FreenoveESP32S3Display*)param;
//       ESP_LOGI(TAG, "Servo test task started - continuous wiggling");
      
//       while(true) {
//           // Sweep pan left to right
//           for(int angle = 45; angle <= 135; angle += 5) {
//               board->SetServoAngle(SERVO_CHANNEL_PAN, (float)angle);
//               vTaskDelay(pdMS_TO_TICKS(50));
//           }
//           for(int angle = 135; angle >= 45; angle -= 5) {
//               board->SetServoAngle(SERVO_CHANNEL_PAN, (float)angle);
//               vTaskDelay(pdMS_TO_TICKS(50));
//           }
          
//           // Sweep tilt up to down
//           for(int angle = 60; angle <= 120; angle += 5) {
//               board->SetServoAngle(SERVO_CHANNEL_TILT, (float)angle);
//               vTaskDelay(pdMS_TO_TICKS(50));
//           }
//           for(int angle = 120; angle >= 60; angle -= 5) {
//               board->SetServoAngle(SERVO_CHANNEL_TILT, (float)angle);
//               vTaskDelay(pdMS_TO_TICKS(50));
//           }
          
//           // Both together - figure 8 pattern
//           for(int i = 0; i < 100; i++) {
//               float t = i / 10.0f;
//               float pan = 90 + 30 * sin(t);
//               float tilt = 90 + 20 * cos(t * 1.5);
//               board->SetServoAngle(SERVO_CHANNEL_PAN, pan);
//               board->SetServoAngle(SERVO_CHANNEL_TILT, tilt);
//               vTaskDelay(pdMS_TO_TICKS(50));
//           }
//       }
//   }

//  public:
//   FreenoveESP32S3Display(): boot_button_(BOOT_BUTTON_GPIO)
//   {
//     InitializeI2c();
//     InitializeSpi();
//     InitializeLcdDisplay();
//     InitializeButtons();
//     InitializeServos();

//     // Startup wiggle test
//     ESP_LOGW(TAG, "--- STARTUP WIGGLE ---");
//     SetServoAngle(SERVO_CHANNEL_PAN, 45.0f);
//     vTaskDelay(pdMS_TO_TICKS(500));
//     SetServoAngle(SERVO_CHANNEL_PAN, 135.0f);
//     vTaskDelay(pdMS_TO_TICKS(500));
//     SetServoAngle(SERVO_CHANNEL_PAN, 90.0f);
//     SetServoAngle(SERVO_CHANNEL_TILT, 90.0f);
//     ESP_LOGW(TAG, "--- WIGGLE DONE ---");

//     InitializeTools(); 
//     GetBacklight()->SetBrightness(100);
    
//     // Start continuous servo test task
//     // xTaskCreate(ServoTestTask, "servo_test", 4096, this, 5, NULL);
//     // ESP_LOGW(TAG, "Continuous servo test enabled - motors will keep wiggling");
//   }

//   void InitializeTools() {
//       auto& mcp_server = McpServer::GetInstance();

//       mcp_server.AddTool("self.head.gesture", 
//           "Perform a physical head gesture to express emotion or reaction. Use this to make interactions more engaging and natural.", 
//           PropertyList({
//               Property("type", kPropertyTypeString, "nod (agreement/yes), shake (disagreement/no), dance (excited/happy), tilt (curious/thinking), wiggle (playful)")
//           }), 
//           [this](const PropertyList& properties) -> ReturnValue {
//               std::string type = properties["type"].value<std::string>();
//               if (type == "nod") GetDisplay()->SetEmotion("happy");
//               else if (type == "shake") GetDisplay()->SetEmotion("sad");
//               else if (type == "dance") GetDisplay()->SetEmotion("music");
//               else if (type == "tilt") GetDisplay()->SetEmotion("curious");
//               else if (type == "wiggle") GetDisplay()->SetEmotion("happy");
//               PerformGesture(type);
//               return "Gesture completed: " + type; 
//           });

//       mcp_server.AddTool("self.head.look_at", 
//           "Direct attention by moving head. Use when referring to directions or showing focus.", 
//           PropertyList({
//               Property("direction", kPropertyTypeString, "center, up, down, left, right")
//           }), 
//           [this](const PropertyList& properties) -> ReturnValue {
//               std::string dir = properties["direction"].value<std::string>();
//               if (dir == "center") { 
//                   SetServoAngle(SERVO_CHANNEL_PAN, 90.0f); 
//                   SetServoAngle(SERVO_CHANNEL_TILT, 90.0f); 
//               }
//               else if (dir == "left") SetServoAngle(SERVO_CHANNEL_PAN, 135.0f);
//               else if (dir == "right") SetServoAngle(SERVO_CHANNEL_PAN, 45.0f);
//               else if (dir == "up") SetServoAngle(SERVO_CHANNEL_TILT, 120.0f);
//               else if (dir == "down") SetServoAngle(SERVO_CHANNEL_TILT, 60.0f);
//               return "Looking " + dir; 
//           });

//       mcp_server.AddTool("self.express_emotion",
//           "Express emotion through combined head movement and display. Use naturally during conversation to show personality and engagement.",
//           PropertyList({
//               Property("emotion", kPropertyTypeString, "happy (nod + smile), sad (look down), excited (wiggle), thinking (tilt), surprised (look up)")
//           }),
//           [this](const PropertyList& properties) -> ReturnValue {
//               std::string emotion = properties["emotion"].value<std::string>();
              
//               if (emotion == "happy") {
//                   GetDisplay()->SetEmotion("happy");
//                   PerformGesture("nod");
//               }
//               else if (emotion == "sad") {
//                   GetDisplay()->SetEmotion("sad");
//                   SetServoAngle(SERVO_CHANNEL_TILT, 70.0f);
//               }
//               else if (emotion == "excited") {
//                   GetDisplay()->SetEmotion("music");
//                   PerformGesture("wiggle");
//               }
//               else if (emotion == "thinking") {
//                   GetDisplay()->SetEmotion("curious");
//                   SetServoAngle(SERVO_CHANNEL_PAN, 110.0f);
//                   vTaskDelay(pdMS_TO_TICKS(300));
//                   SetServoAngle(SERVO_CHANNEL_TILT, 100.0f);
//               }
//               else if (emotion == "surprised") {
//                   GetDisplay()->SetEmotion("happy");
//                   SetServoAngle(SERVO_CHANNEL_TILT, 120.0f);
//                   vTaskDelay(pdMS_TO_TICKS(200));
//                   SetServoAngle(SERVO_CHANNEL_PAN, 80.0f);
//                   vTaskDelay(pdMS_TO_TICKS(200));
//                   SetServoAngle(SERVO_CHANNEL_PAN, 100.0f);
//               }
              
//               return "Expressed: " + emotion;
//           });

//       mcp_server.AddTool("self.get_weather", 
//         "Get local weather.", 
//         PropertyList({ Property("location", kPropertyTypeString, "City name") }), 
//         [this](const PropertyList& properties) -> ReturnValue {
//             std::string location = properties["location"].value<std::string>();
//             GetDisplay()->SetChatMessage("assistant", ("Checking weather for " + location).c_str());
//             return "Weather tool executed."; 
//         });

//       mcp_server.AddTool("self.music_player.play", 
//         "Play music URL.", 
//         PropertyList({ Property("url", kPropertyTypeString, "URL") }), 
//         [this](const PropertyList& properties) -> ReturnValue {
//             GetDisplay()->SetChatMessage("assistant", "Playing music...");
//             GetDisplay()->SetEmotion("music");
//             PerformGesture("dance");
//             return "Music started.";
//         });
//   }
  
//   virtual void TriggerGesture(const std::string& gesture) {
//       PerformGesture(gesture);
//   }

//   virtual Led *GetLed() override { 
//       static SingleLed led(BUILTIN_LED_GPIO); 
//       return &led; 
//   }
  
//   virtual AudioCodec* GetAudioCodec() override {
//     static Es8311AudioCodec audio_codec(codec_i2c_bus_, AUDIO_CODEC_I2C_NUM,
//       AUDIO_INPUT_SAMPLE_RATE, AUDIO_OUTPUT_SAMPLE_RATE, AUDIO_I2S_GPIO_MCLK, 
//       AUDIO_I2S_GPIO_BCLK, AUDIO_I2S_GPIO_WS, AUDIO_I2S_GPIO_DOUT, 
//       AUDIO_I2S_GPIO_DIN, AUDIO_CODEC_PA_PIN, AUDIO_CODEC_ES8311_ADDR, 
//       true, true);
//     return &audio_codec;
//   }
  
//   virtual Display *GetDisplay() override { 
//       return display_; 
//   }
  
//   virtual Backlight *GetBacklight() override { 
//       static PwmBacklight b(DISPLAY_BACKLIGHT_PIN, DISPLAY_BACKLIGHT_OUTPUT_INVERT); 
//       return &b; 
//   }
// };

// DECLARE_BOARD(FreenoveESP32S3Display);


// // gemini improved 2 motor -- works
// #include <driver/i2c_master.h>
// #include <driver/spi_common.h>
// #include <driver/ledc.h>
// #include <freertos/FreeRTOS.h>
// #include <freertos/task.h>
// #include <freertos/queue.h>
// #include <esp_log.h>
// #include <math.h>

// #include "esp_lcd_panel_vendor.h"
// #include "esp_lcd_panel_io.h"
// #include "esp_lcd_panel_ops.h"
// #include "wifi_station.h"
// #include "application.h"
// #include "audio/codecs/es8311_audio_codec.h"
// #include "button.h"
// #include "display/lcd_display.h"
// #include "led/single_led.h"
// #include "system_reset.h"
// #include "wifi_board.h"
// #include "mcp_server.h"
// #include "config.h"
// #include "esp_lcd_ili9341.h"

// #define TAG "FreenoveBoard"

// // --- SERVO CONFIG ---
// #define SERVO_PAN_PIN       GPIO_NUM_3
// #define SERVO_TILT_PIN      GPIO_NUM_21
// #define SERVO_FREQ          50
// #define SERVO_TIMER         LEDC_TIMER_3
// #define SERVO_RESOLUTION    LEDC_TIMER_14_BIT
// #define SERVO_CHANNEL_PAN   LEDC_CHANNEL_2
// #define SERVO_CHANNEL_TILT  LEDC_CHANNEL_3

// // Calibrated Pulse Widths
// #define SERVO_MIN_PULSEWIDTH_US  350  
// #define SERVO_MAX_PULSEWIDTH_US  2270 
// #define SERVO_PERIOD_US          20000

// // --- GESTURE DEFINITIONS ---
// enum GestureType {
//     GESTURE_NONE,
//     GESTURE_NOD,
//     GESTURE_SHAKE,
//     GESTURE_DANCE,
//     GESTURE_TILT,
//     GESTURE_WIGGLE,
//     GESTURE_LOOK_UP,
//     GESTURE_LOOK_DOWN,
//     GESTURE_LOOK_LEFT,
//     GESTURE_LOOK_RIGHT,
//     GESTURE_CENTER
// };

// struct ServoCommand {
//     GestureType type;
// };

// class FreenoveESP32S3Display : public WifiBoard {
// private:
//     Button boot_button_;
//     LcdDisplay *display_;
//     i2c_master_bus_handle_t codec_i2c_bus_;
//     QueueHandle_t servo_queue_;
//     TaskHandle_t servo_task_handle_;

//     // --- LOW LEVEL SERVO CONTROL ---
//     uint32_t AngleToDuty(float angle) {
//         if (angle < 0.0f) angle = 0.0f;
//         if (angle > 180.0f) angle = 180.0f;
//         uint32_t pulse_us = SERVO_MIN_PULSEWIDTH_US + 
//             (uint32_t)((SERVO_MAX_PULSEWIDTH_US - SERVO_MIN_PULSEWIDTH_US) * angle / 180.0f);
//         uint32_t max_duty = (1 << SERVO_RESOLUTION) - 1;
//         return (pulse_us * max_duty) / SERVO_PERIOD_US;
//     }

//     void SetServoAngle(ledc_channel_t channel, float angle) {
//         ledc_set_duty(LEDC_LOW_SPEED_MODE, channel, AngleToDuty(angle));
//         ledc_update_duty(LEDC_LOW_SPEED_MODE, channel);
//     }

//     // --- ANIMATION LOGIC (Runs in background task) ---
//     void ExecuteGesture(GestureType gesture) {
//         switch(gesture) {
//             case GESTURE_NOD:
//                 for(int i=0; i<3; i++) {
//                     SetServoAngle(SERVO_CHANNEL_TILT, 110.0f); vTaskDelay(pdMS_TO_TICKS(150));
//                     SetServoAngle(SERVO_CHANNEL_TILT, 70.0f);  vTaskDelay(pdMS_TO_TICKS(150));
//                 }
//                 SetServoAngle(SERVO_CHANNEL_TILT, 90.0f);
//                 break;
//             case GESTURE_SHAKE:
//                 for(int i=0; i<3; i++) {
//                     SetServoAngle(SERVO_CHANNEL_PAN, 120.0f); vTaskDelay(pdMS_TO_TICKS(150));
//                     SetServoAngle(SERVO_CHANNEL_PAN, 60.0f);  vTaskDelay(pdMS_TO_TICKS(150));
//                 }
//                 SetServoAngle(SERVO_CHANNEL_PAN, 90.0f);
//                 break;
//             case GESTURE_DANCE: {
//                 uint32_t start = esp_log_timestamp();
//                 while (esp_log_timestamp() - start < 4000) {
//                     float t = (esp_log_timestamp() - start) / 400.0;
//                     SetServoAngle(SERVO_CHANNEL_PAN, (sin(t) * 30) + 90);
//                     SetServoAngle(SERVO_CHANNEL_TILT, (cos(t) * 30) + 90);
//                     vTaskDelay(pdMS_TO_TICKS(20));
//                 }
//                 SetServoAngle(SERVO_CHANNEL_PAN, 90.0f);
//                 SetServoAngle(SERVO_CHANNEL_TILT, 90.0f);
//                 break;
//             }
//             case GESTURE_TILT:
//                 SetServoAngle(SERVO_CHANNEL_PAN, 110.0f);
//                 vTaskDelay(pdMS_TO_TICKS(300));
//                 SetServoAngle(SERVO_CHANNEL_TILT, 100.0f);
//                 vTaskDelay(pdMS_TO_TICKS(800));
//                 SetServoAngle(SERVO_CHANNEL_PAN, 90.0f);
//                 SetServoAngle(SERVO_CHANNEL_TILT, 90.0f);
//                 break;
//             case GESTURE_WIGGLE:
//                 for(int i=0; i<4; i++) {
//                     SetServoAngle(SERVO_CHANNEL_PAN, 100.0f); vTaskDelay(pdMS_TO_TICKS(100));
//                     SetServoAngle(SERVO_CHANNEL_PAN, 80.0f);  vTaskDelay(pdMS_TO_TICKS(100));
//                 }
//                 SetServoAngle(SERVO_CHANNEL_PAN, 90.0f);
//                 break;
//             case GESTURE_CENTER:
//                 SetServoAngle(SERVO_CHANNEL_PAN, 90.0f);
//                 SetServoAngle(SERVO_CHANNEL_TILT, 90.0f);
//                 break;
//             case GESTURE_LOOK_LEFT: SetServoAngle(SERVO_CHANNEL_PAN, 135.0f); break;
//             case GESTURE_LOOK_RIGHT: SetServoAngle(SERVO_CHANNEL_PAN, 45.0f); break;
//             case GESTURE_LOOK_UP: SetServoAngle(SERVO_CHANNEL_TILT, 120.0f); break;
//             case GESTURE_LOOK_DOWN: SetServoAngle(SERVO_CHANNEL_TILT, 60.0f); break;
//             default: break;
//         }
//     }

//     static void ServoTask(void* arg) {
//         FreenoveESP32S3Display* board = (FreenoveESP32S3Display*)arg;
//         ServoCommand cmd;
//         while(true) {
//             if(xQueueReceive(board->servo_queue_, &cmd, portMAX_DELAY)) {
//                 board->ExecuteGesture(cmd.type);
//             }
//         }
//     }

//     void QueueGesture(GestureType type) {
//         ServoCommand cmd = { type };
//         xQueueSend(servo_queue_, &cmd, 0); // Non-blocking send
//     }

// public:
//     FreenoveESP32S3Display() : boot_button_(BOOT_BUTTON_GPIO) {
//         InitializeI2c();
//         InitializeSpi();
//         InitializeLcdDisplay();
//         InitializeButtons();
//         InitializeServos();
        
//         // Initialize Servo Task Queue
//         servo_queue_ = xQueueCreate(5, sizeof(ServoCommand));
//         xTaskCreate(ServoTask, "servo_task", 4096, this, 5, &servo_task_handle_);
        
//         // Startup Wiggle
//         QueueGesture(GESTURE_WIGGLE);

//         InitializeTools(); 
//         GetBacklight()->SetBrightness(100);
//     }

//     void InitializeServos() {
//         ledc_timer_config_t timer_conf = {
//             .speed_mode = LEDC_LOW_SPEED_MODE,
//             .duty_resolution = SERVO_RESOLUTION,
//             .timer_num = SERVO_TIMER,
//             .freq_hz = SERVO_FREQ,
//             .clk_cfg = LEDC_AUTO_CLK
//         };
//         ledc_timer_config(&timer_conf);

//         ledc_channel_config_t pan_conf = {
//             .gpio_num = SERVO_PAN_PIN,
//             .speed_mode = LEDC_LOW_SPEED_MODE,
//             .channel = SERVO_CHANNEL_PAN,
//             .intr_type = LEDC_INTR_DISABLE,
//             .timer_sel = SERVO_TIMER,
//             .duty = AngleToDuty(90),
//             .hpoint = 0
//         };
//         ledc_channel_config(&pan_conf);

//         ledc_channel_config_t tilt_conf = {
//             .gpio_num = SERVO_TILT_PIN,
//             .speed_mode = LEDC_LOW_SPEED_MODE,
//             .channel = SERVO_CHANNEL_TILT,
//             .intr_type = LEDC_INTR_DISABLE,
//             .timer_sel = SERVO_TIMER,
//             .duty = AngleToDuty(90),
//             .hpoint = 0
//         };
//         ledc_channel_config(&tilt_conf);
//     }

//     void InitializeTools() {
//         auto& mcp = McpServer::GetInstance();

//         // TOOL: self.head.gesture
//         mcp.AddTool("self.head.gesture", 
//             "Perform a head gesture.", 
//             PropertyList({
//                 Property("type", kPropertyTypeString, "nod, shake, dance, tilt, wiggle")
//             }), 
//             [this](const PropertyList& props) -> ReturnValue {
//                 std::string type = props["type"].value<std::string>();
//                 if (type == "nod") QueueGesture(GESTURE_NOD);
//                 else if (type == "shake") QueueGesture(GESTURE_SHAKE);
//                 else if (type == "dance") QueueGesture(GESTURE_DANCE);
//                 else if (type == "tilt") QueueGesture(GESTURE_TILT);
//                 else if (type == "wiggle") QueueGesture(GESTURE_WIGGLE);
//                 return "Gesture started: " + type; 
//             });

//         // TOOL: self.head.look_at
//         mcp.AddTool("self.head.look_at", 
//             "Look in a direction.", 
//             PropertyList({
//                 Property("direction", kPropertyTypeString, "center, up, down, left, right")
//             }), 
//             [this](const PropertyList& props) -> ReturnValue {
//                 std::string dir = props["direction"].value<std::string>();
//                 if (dir == "center") QueueGesture(GESTURE_CENTER);
//                 else if (dir == "left") QueueGesture(GESTURE_LOOK_LEFT);
//                 else if (dir == "right") QueueGesture(GESTURE_LOOK_RIGHT);
//                 else if (dir == "up") QueueGesture(GESTURE_LOOK_UP);
//                 else if (dir == "down") QueueGesture(GESTURE_LOOK_DOWN);
//                 return "Looking " + dir; 
//             });

//         // TOOL: self.express_emotion
//         mcp.AddTool("self.express_emotion",
//             "Express emotion with face and head.",
//             PropertyList({
//                 Property("emotion", kPropertyTypeString, "happy, sad, excited, thinking, surprised")
//             }),
//             [this](const PropertyList& props) -> ReturnValue {
//                 std::string emotion = props["emotion"].value<std::string>();
//                 if (emotion == "happy") {
//                     GetDisplay()->SetEmotion("happy");
//                     QueueGesture(GESTURE_NOD);
//                 } else if (emotion == "sad") {
//                     GetDisplay()->SetEmotion("sad");
//                     QueueGesture(GESTURE_LOOK_DOWN);
//                 } else if (emotion == "excited") {
//                     GetDisplay()->SetEmotion("music");
//                     QueueGesture(GESTURE_WIGGLE);
//                 } else if (emotion == "thinking") {
//                     GetDisplay()->SetEmotion("curious");
//                     QueueGesture(GESTURE_TILT);
//                 } else if (emotion == "surprised") {
//                     GetDisplay()->SetEmotion("happy");
//                     QueueGesture(GESTURE_LOOK_UP);
//                 }
//                 return "Expressed: " + emotion;
//             });
//     }

//     // --- STANDARD BOILERPLATE BELOW ---
//     void InitializeSpi() {
//         spi_bus_config_t buscfg = {};
//         buscfg.mosi_io_num = DISPLAY_MOSI_PIN;
//         buscfg.miso_io_num = DISPLAY_MIS0_PIN;
//         buscfg.sclk_io_num = DISPLAY_SCK_PIN;
//         buscfg.quadwp_io_num = GPIO_NUM_NC;
//         buscfg.quadhd_io_num = GPIO_NUM_NC;
//         buscfg.max_transfer_sz = DISPLAY_WIDTH * DISPLAY_HEIGHT * sizeof(uint16_t);
//         ESP_ERROR_CHECK(spi_bus_initialize(LCD_SPI_HOST, &buscfg, SPI_DMA_CH_AUTO));
//     }

//     void InitializeLcdDisplay() {
//         esp_lcd_panel_io_handle_t panel_io = nullptr;
//         esp_lcd_panel_handle_t panel = nullptr;
//         esp_lcd_panel_io_spi_config_t io_config = {};
//         io_config.cs_gpio_num = DISPLAY_CS_PIN;
//         io_config.dc_gpio_num = DISPLAY_DC_PIN;
//         io_config.spi_mode = DISPLAY_SPI_MODE;
//         io_config.pclk_hz = DISPLAY_SPI_SCLK_HZ;
//         io_config.trans_queue_depth = 10;
//         io_config.lcd_cmd_bits = 8;
//         io_config.lcd_param_bits = 8;
//         ESP_ERROR_CHECK(esp_lcd_new_panel_io_spi(LCD_SPI_HOST, &io_config, &panel_io));
        
//         esp_lcd_panel_dev_config_t panel_config = {};
//         panel_config.reset_gpio_num = DISPLAY_RST_PIN;
//         panel_config.rgb_ele_order = DISPLAY_RGB_ORDER;
//         panel_config.bits_per_pixel = 16;
//         ESP_ERROR_CHECK(esp_lcd_new_panel_ili9341(panel_io, &panel_config, &panel));
//         esp_lcd_panel_reset(panel);
//         esp_lcd_panel_init(panel);
//         esp_lcd_panel_invert_color(panel, DISPLAY_INVERT_COLOR);
//         esp_lcd_panel_swap_xy(panel, DISPLAY_SWAP_XY);
//         esp_lcd_panel_mirror(panel, DISPLAY_MIRROR_X, DISPLAY_MIRROR_Y);
        
//         display_ = new SpiLcdDisplay(panel_io, panel, 
//             DISPLAY_WIDTH, DISPLAY_HEIGHT, DISPLAY_OFFSET_X, DISPLAY_OFFSET_Y, 
//             DISPLAY_MIRROR_X, DISPLAY_MIRROR_Y, DISPLAY_SWAP_XY);
//     }

//     void InitializeI2c() {
//         i2c_master_bus_config_t i2c_bus_cfg = {
//             .i2c_port = AUDIO_CODEC_I2C_NUM,
//             .sda_io_num = AUDIO_CODEC_I2C_SDA_PIN,
//             .scl_io_num = AUDIO_CODEC_I2C_SCL_PIN,
//             .clk_source = I2C_CLK_SRC_DEFAULT,
//             .glitch_ignore_cnt = 7,
//             .intr_priority = 0,
//             .trans_queue_depth = 0,
//             .flags = { .enable_internal_pullup = 1 },
//         };
//         ESP_ERROR_CHECK(i2c_new_master_bus(&i2c_bus_cfg, &codec_i2c_bus_));
//     }

//     void InitializeButtons() {
//         boot_button_.OnClick([this]() {
//             auto &app = Application::GetInstance();
//             if (app.GetDeviceState() == kDeviceStateStarting && !WifiStation::GetInstance().IsConnected()) {
//                 ResetWifiConfiguration();
//             }
//             app.ToggleChatState();
//         });
//     }

//     virtual Led *GetLed() override { 
//         static SingleLed led(BUILTIN_LED_GPIO); 
//         return &led; 
//     }
    
//     virtual AudioCodec* GetAudioCodec() override {
//         static Es8311AudioCodec audio_codec(codec_i2c_bus_, AUDIO_CODEC_I2C_NUM,
//             AUDIO_INPUT_SAMPLE_RATE, AUDIO_OUTPUT_SAMPLE_RATE, AUDIO_I2S_GPIO_MCLK, 
//             AUDIO_I2S_GPIO_BCLK, AUDIO_I2S_GPIO_WS, AUDIO_I2S_GPIO_DOUT, 
//             AUDIO_I2S_GPIO_DIN, AUDIO_CODEC_PA_PIN, AUDIO_CODEC_ES8311_ADDR, 
//             true, true);
//         return &audio_codec;
//     }
    
//     virtual Display *GetDisplay() override { return display_; }
//     virtual Backlight *GetBacklight() override { 
//         static PwmBacklight b(DISPLAY_BACKLIGHT_PIN, DISPLAY_BACKLIGHT_OUTPUT_INVERT); 
//         return &b; 
//     }
// };

// DECLARE_BOARD(FreenoveESP32S3Display);


// genimi 3 motors -working, but robust
// #include <driver/i2c_master.h>
// #include <driver/spi_common.h>
// #include <driver/ledc.h>
// #include <driver/gpio.h>
// #include <freertos/FreeRTOS.h>
// #include <freertos/task.h>
// #include <freertos/queue.h>
// #include <esp_log.h>
// #include <math.h>

// #include "esp_lcd_panel_vendor.h"
// #include "esp_lcd_panel_io.h"
// #include "esp_lcd_panel_ops.h"
// #include "wifi_station.h"
// #include "application.h"
// #include "audio/codecs/es8311_audio_codec.h"
// #include "button.h"
// #include "display/lcd_display.h"
// #include "led/single_led.h"
// #include "system_reset.h"
// #include "wifi_board.h"
// #include "mcp_server.h"
// #include "config.h"
// #include "esp_lcd_ili9341.h"

// #define TAG "Freenove3Axis"

// // --- MOTOR PIN CONFIGURATION ---
// // Verified Pins: 3, 21, 2
// #define SERVO_PAN_PIN       GPIO_NUM_3   // X-Axis
// #define SERVO_TILT_PIN      GPIO_NUM_21  // Y-Axis
// #define SERVO_ROLL_PIN      GPIO_NUM_2   // Z-Axis (Reclaimed from LED)

// // --- SERVO CONFIG ---
// #define SERVO_FREQ          50
// #define SERVO_TIMER         LEDC_TIMER_3
// #define SERVO_RESOLUTION    LEDC_TIMER_14_BIT
// #define SERVO_CHANNEL_PAN   LEDC_CHANNEL_2
// #define SERVO_CHANNEL_TILT  LEDC_CHANNEL_3
// #define SERVO_CHANNEL_ROLL  LEDC_CHANNEL_4

// #define SERVO_MIN_US        500 
// #define SERVO_MAX_US        2500
// #define SERVO_PERIOD_US     20000

// // --- DUMMY LED CLASS (FIXED) ---
// class NoOpLed : public Led {
// public:
//     // FIX: We must implement OnStateChanged, not Set/Blink.
//     // The base class handles logic and calls this to physically toggle the pin.
//     // We do nothing here to keep Pin 2 free for the servo.
//     void OnStateChanged() override {
//         // Do nothing.
//     }
// };

// // --- GESTURE DEFINITIONS ---
// enum GestureType {
//     GESTURE_NONE,
//     GESTURE_NOD,
//     GESTURE_SHAKE,
//     GESTURE_CONFUSED, 
//     GESTURE_DANCE,
//     GESTURE_TILT,     
//     GESTURE_WIGGLE,
//     GESTURE_LOOK_UP,   // Added back
//     GESTURE_LOOK_DOWN, // Added back
//     GESTURE_CENTER
// };

// struct ServoCommand {
//     GestureType type;
// };

// class FreenoveESP32S3Display : public WifiBoard {
// private:
//     Button boot_button_;
//     LcdDisplay *display_;
//     i2c_master_bus_handle_t codec_i2c_bus_;
//     QueueHandle_t servo_queue_;
//     TaskHandle_t servo_task_handle_;

//     // --- LOW LEVEL SERVO CONTROL ---
//     uint32_t AngleToDuty(float angle) {
//         if (angle < 0.0f) angle = 0.0f;
//         if (angle > 180.0f) angle = 180.0f;
//         uint32_t pulse_us = SERVO_MIN_US + (uint32_t)((SERVO_MAX_US - SERVO_MIN_US) * angle / 180.0f);
//         uint32_t max_duty = (1 << SERVO_RESOLUTION) - 1;
//         return (pulse_us * max_duty) / SERVO_PERIOD_US;
//     }

//     void SetAngles(float pan, float tilt, float roll) {
//         ledc_set_duty(LEDC_LOW_SPEED_MODE, SERVO_CHANNEL_PAN, AngleToDuty(pan));
//         ledc_update_duty(LEDC_LOW_SPEED_MODE, SERVO_CHANNEL_PAN);
        
//         ledc_set_duty(LEDC_LOW_SPEED_MODE, SERVO_CHANNEL_TILT, AngleToDuty(tilt));
//         ledc_update_duty(LEDC_LOW_SPEED_MODE, SERVO_CHANNEL_TILT);

//         ledc_set_duty(LEDC_LOW_SPEED_MODE, SERVO_CHANNEL_ROLL, AngleToDuty(roll));
//         ledc_update_duty(LEDC_LOW_SPEED_MODE, SERVO_CHANNEL_ROLL);
//     }

//     // --- ANIMATION LOGIC ---
//     void ExecuteGesture(GestureType gesture) {
//         switch(gesture) {
//             case GESTURE_NOD:
//                 for(int i=0; i<3; i++) {
//                     SetAngles(90, 115, 90); vTaskDelay(pdMS_TO_TICKS(150));
//                     SetAngles(90, 70, 90);  vTaskDelay(pdMS_TO_TICKS(150));
//                 }
//                 SmoothReturnCenter();
//                 break;

//             case GESTURE_SHAKE:
//                 for(int i=0; i<3; i++) {
//                     SetAngles(120, 90, 90); vTaskDelay(pdMS_TO_TICKS(150));
//                     SetAngles(60, 90, 90);  vTaskDelay(pdMS_TO_TICKS(150));
//                 }
//                 SmoothReturnCenter();
//                 break;

//             case GESTURE_CONFUSED:
//                 SetAngles(90, 100, 135); 
//                 vTaskDelay(pdMS_TO_TICKS(2000));
//                 SmoothReturnCenter();
//                 break;

//             case GESTURE_DANCE: {
//                 uint32_t start = esp_log_timestamp();
//                 while (esp_log_timestamp() - start < 4000) {
//                     float t = (esp_log_timestamp() - start) / 300.0;
//                     float pan = (sin(t) * 30) + 90;
//                     float tilt = (cos(t) * 20) + 90;
//                     float roll = (sin(t*2) * 25) + 90; 
//                     SetAngles(pan, tilt, roll);
//                     vTaskDelay(pdMS_TO_TICKS(20));
//                 }
//                 SmoothReturnCenter();
//                 break;
//             }

//             case GESTURE_TILT: // Thinking
//                 SetAngles(110, 120, 100);
//                 vTaskDelay(pdMS_TO_TICKS(2000));
//                 SmoothReturnCenter();
//                 break;

//             case GESTURE_WIGGLE:
//                 for(int i=0; i<4; i++) {
//                     SetAngles(100, 90, 100); vTaskDelay(pdMS_TO_TICKS(100));
//                     SetAngles(80, 90, 80);   vTaskDelay(pdMS_TO_TICKS(100));
//                 }
//                 SmoothReturnCenter();
//                 break;
            
//             case GESTURE_LOOK_DOWN:
//                 SetAngles(90, 60, 90); // Look down
//                 break; // Stays there until next command

//             case GESTURE_LOOK_UP:
//                 SetAngles(90, 120, 90); // Look up
//                 break;

//             default: // CENTER
//                 SmoothReturnCenter();
//                 break;
//         }
//     }

//     void SmoothReturnCenter() {
//         SetAngles(90, 90, 90);
//     }

//     static void ServoTask(void* arg) {
//         FreenoveESP32S3Display* board = (FreenoveESP32S3Display*)arg;
//         ServoCommand cmd;
//         while(true) {
//             if(xQueueReceive(board->servo_queue_, &cmd, portMAX_DELAY)) {
//                 board->ExecuteGesture(cmd.type);
//             }
//         }
//     }

//     void QueueGesture(GestureType type) {
//         ServoCommand cmd = { type };
//         xQueueSend(servo_queue_, &cmd, 0); 
//     }

// public:
//     FreenoveESP32S3Display() : boot_button_(BOOT_BUTTON_GPIO) {
//         InitializeI2c();
//         InitializeSpi();
//         InitializeLcdDisplay();
//         InitializeButtons();

//         // Safe Reset of Motor Pins
//         gpio_reset_pin(SERVO_PAN_PIN);
//         gpio_reset_pin(SERVO_TILT_PIN);
//         gpio_reset_pin(SERVO_ROLL_PIN);
//         vTaskDelay(pdMS_TO_TICKS(50));

//         InitializeServos();
        
//         servo_queue_ = xQueueCreate(5, sizeof(ServoCommand));
//         xTaskCreate(ServoTask, "servo_task", 4096, this, 5, &servo_task_handle_);
        
//         // Startup Expression
//         QueueGesture(GESTURE_CONFUSED);

//         InitializeTools(); 
//         GetBacklight()->SetBrightness(100);
//     }

//     void InitializeServos() {
//         ledc_timer_config_t timer_conf = {
//             .speed_mode = LEDC_LOW_SPEED_MODE,
//             .duty_resolution = SERVO_RESOLUTION,
//             .timer_num = SERVO_TIMER,
//             .freq_hz = SERVO_FREQ,
//             .clk_cfg = LEDC_AUTO_CLK
//         };
//         ledc_timer_config(&timer_conf);

//         // Pan - Pin 3
//         ledc_channel_config_t pan_conf = {
//             .gpio_num = SERVO_PAN_PIN,
//             .speed_mode = LEDC_LOW_SPEED_MODE,
//             .channel = SERVO_CHANNEL_PAN,
//             .intr_type = LEDC_INTR_DISABLE,
//             .timer_sel = SERVO_TIMER,
//             .duty = AngleToDuty(90),
//             .hpoint = 0
//         };
//         ledc_channel_config(&pan_conf);

//         // Tilt - Pin 21
//         ledc_channel_config_t tilt_conf = {
//             .gpio_num = SERVO_TILT_PIN,
//             .speed_mode = LEDC_LOW_SPEED_MODE,
//             .channel = SERVO_CHANNEL_TILT,
//             .intr_type = LEDC_INTR_DISABLE,
//             .timer_sel = SERVO_TIMER,
//             .duty = AngleToDuty(90),
//             .hpoint = 0
//         };
//         ledc_channel_config(&tilt_conf);

//         // Roll - Pin 2 (Reclaimed from LED)
//         ledc_channel_config_t roll_conf = {
//             .gpio_num = SERVO_ROLL_PIN,
//             .speed_mode = LEDC_LOW_SPEED_MODE,
//             .channel = SERVO_CHANNEL_ROLL,
//             .intr_type = LEDC_INTR_DISABLE,
//             .timer_sel = SERVO_TIMER,
//             .duty = AngleToDuty(90),
//             .hpoint = 0
//         };
//         ledc_channel_config(&roll_conf);
//     }

//     void InitializeTools() {
//         auto& mcp = McpServer::GetInstance();

//         // TOOL: self.express_emotion
//         mcp.AddTool("self.express_emotion",
//             "Express emotion with face and 3-axis head movement.",
//             PropertyList({
//                 Property("emotion", kPropertyTypeString, "happy, sad, excited, thinking, confused, neutral")
//             }),
//             [this](const PropertyList& props) -> ReturnValue {
//                 std::string emotion = props["emotion"].value<std::string>();
                
//                 if (emotion == "happy") {
//                     GetDisplay()->SetEmotion("happy");
//                     QueueGesture(GESTURE_NOD);
//                 } else if (emotion == "sad") {
//                     GetDisplay()->SetEmotion("sad");
//                     QueueGesture(GESTURE_LOOK_DOWN); // Fixed: Now exists
//                 } else if (emotion == "excited") {
//                     GetDisplay()->SetEmotion("music");
//                     QueueGesture(GESTURE_DANCE);
//                 } else if (emotion == "thinking") {
//                     GetDisplay()->SetEmotion("curious");
//                     QueueGesture(GESTURE_TILT);
//                 } else if (emotion == "confused") {
//                     GetDisplay()->SetEmotion("curious");
//                     QueueGesture(GESTURE_CONFUSED);
//                 } else {
//                     GetDisplay()->SetEmotion("neutral");
//                     QueueGesture(GESTURE_CENTER);
//                 }
//                 return "Expressed: " + emotion;
//             });
//     }

//     // --- OVERRIDES ---

//     // 1. Disable the Onboard LED logic
//     virtual Led *GetLed() override { 
//         static NoOpLed led; 
//         return &led; 
//     }
    
//     // 2. Keep Backlight Standard (Pin 14)
//     virtual Backlight *GetBacklight() override { 
//         static PwmBacklight b(DISPLAY_BACKLIGHT_PIN, DISPLAY_BACKLIGHT_OUTPUT_INVERT); 
//         return &b; 
//     }

//     // --- STANDARD BOILERPLATE BELOW ---
//     void InitializeSpi() {
//         spi_bus_config_t buscfg = {};
//         buscfg.mosi_io_num = DISPLAY_MOSI_PIN;
//         buscfg.miso_io_num = DISPLAY_MIS0_PIN;
//         buscfg.sclk_io_num = DISPLAY_SCK_PIN;
//         buscfg.quadwp_io_num = GPIO_NUM_NC;
//         buscfg.quadhd_io_num = GPIO_NUM_NC;
//         buscfg.max_transfer_sz = DISPLAY_WIDTH * DISPLAY_HEIGHT * sizeof(uint16_t);
//         ESP_ERROR_CHECK(spi_bus_initialize(LCD_SPI_HOST, &buscfg, SPI_DMA_CH_AUTO));
//     }

//     void InitializeLcdDisplay() {
//         esp_lcd_panel_io_handle_t panel_io = nullptr;
//         esp_lcd_panel_handle_t panel = nullptr;
//         esp_lcd_panel_io_spi_config_t io_config = {};
//         io_config.cs_gpio_num = DISPLAY_CS_PIN;
//         io_config.dc_gpio_num = DISPLAY_DC_PIN;
//         io_config.spi_mode = DISPLAY_SPI_MODE;
//         io_config.pclk_hz = DISPLAY_SPI_SCLK_HZ;
//         io_config.trans_queue_depth = 10;
//         io_config.lcd_cmd_bits = 8;
//         io_config.lcd_param_bits = 8;
//         ESP_ERROR_CHECK(esp_lcd_new_panel_io_spi(LCD_SPI_HOST, &io_config, &panel_io));
        
//         esp_lcd_panel_dev_config_t panel_config = {};
//         panel_config.reset_gpio_num = DISPLAY_RST_PIN;
//         panel_config.rgb_ele_order = DISPLAY_RGB_ORDER;
//         panel_config.bits_per_pixel = 16;
//         ESP_ERROR_CHECK(esp_lcd_new_panel_ili9341(panel_io, &panel_config, &panel));
//         esp_lcd_panel_reset(panel);
//         esp_lcd_panel_init(panel);
//         esp_lcd_panel_invert_color(panel, DISPLAY_INVERT_COLOR);
//         esp_lcd_panel_swap_xy(panel, DISPLAY_SWAP_XY);
//         esp_lcd_panel_mirror(panel, DISPLAY_MIRROR_X, DISPLAY_MIRROR_Y);
        
//         display_ = new SpiLcdDisplay(panel_io, panel, 
//             DISPLAY_WIDTH, DISPLAY_HEIGHT, DISPLAY_OFFSET_X, DISPLAY_OFFSET_Y, 
//             DISPLAY_MIRROR_X, DISPLAY_MIRROR_Y, DISPLAY_SWAP_XY);
//     }

//     void InitializeI2c() {
//         i2c_master_bus_config_t i2c_bus_cfg = {
//             .i2c_port = AUDIO_CODEC_I2C_NUM,
//             .sda_io_num = AUDIO_CODEC_I2C_SDA_PIN,
//             .scl_io_num = AUDIO_CODEC_I2C_SCL_PIN,
//             .clk_source = I2C_CLK_SRC_DEFAULT,
//             .glitch_ignore_cnt = 7,
//             .intr_priority = 0,
//             .trans_queue_depth = 0,
//             .flags = { .enable_internal_pullup = 1 },
//         };
//         ESP_ERROR_CHECK(i2c_new_master_bus(&i2c_bus_cfg, &codec_i2c_bus_));
//     }

//     void InitializeButtons() {
//         boot_button_.OnClick([this]() {
//             auto &app = Application::GetInstance();
//             if (app.GetDeviceState() == kDeviceStateStarting && !WifiStation::GetInstance().IsConnected()) {
//                 ResetWifiConfiguration();
//             }
//             app.ToggleChatState();
//         });
//     }

//     virtual AudioCodec* GetAudioCodec() override {
//         static Es8311AudioCodec audio_codec(codec_i2c_bus_, AUDIO_CODEC_I2C_NUM,
//             AUDIO_INPUT_SAMPLE_RATE, AUDIO_OUTPUT_SAMPLE_RATE, AUDIO_I2S_GPIO_MCLK, 
//             AUDIO_I2S_GPIO_BCLK, AUDIO_I2S_GPIO_WS, AUDIO_I2S_GPIO_DOUT, 
//             AUDIO_I2S_GPIO_DIN, AUDIO_CODEC_PA_PIN, AUDIO_CODEC_ES8311_ADDR, 
//             true, true);
//         return &audio_codec;
//     }
    
//     virtual Display *GetDisplay() override { return display_; }
// };

// DECLARE_BOARD(FreenoveESP32S3Display);


// //gemini smoother
// #include <driver/i2c_master.h>
// #include <driver/spi_common.h>
// #include <driver/ledc.h>
// #include <driver/gpio.h>
// #include <freertos/FreeRTOS.h>
// #include <freertos/task.h>
// #include <freertos/queue.h>
// #include <esp_log.h>
// #include <math.h>

// #include "esp_lcd_panel_vendor.h"
// #include "esp_lcd_panel_io.h"
// #include "esp_lcd_panel_ops.h"
// #include "wifi_station.h"
// #include "application.h"
// #include "audio/codecs/es8311_audio_codec.h"
// #include "button.h"
// #include "display/lcd_display.h"
// #include "led/single_led.h"
// #include "system_reset.h"
// #include "wifi_board.h"
// #include "mcp_server.h"
// #include "config.h"
// #include "esp_lcd_ili9341.h"

// #define TAG "FreenovePhysics"

// // --- PIN CONFIGURATION (Verified) ---
// #define SERVO_PAN_PIN       GPIO_NUM_14   // X-Axis (Left/Right)
// #define SERVO_TILT_PIN      GPIO_NUM_21  // Y-Axis (Up/Down)
// #define SERVO_ROLL_PIN      GPIO_NUM_2   // Z-Axis (Cute Tilt)

// // --- SETTINGS ---
// #define SERVO_FREQ          50
// #define SERVO_TIMER         LEDC_TIMER_3
// #define SERVO_RESOLUTION    LEDC_TIMER_14_BIT
// #define SERVO_CHANNEL_PAN   LEDC_CHANNEL_2
// #define SERVO_CHANNEL_TILT  LEDC_CHANNEL_3
// #define SERVO_CHANNEL_ROLL  LEDC_CHANNEL_4

// #define SERVO_MIN_US        500 
// #define SERVO_MAX_US        2500
// #define SERVO_PERIOD_US     20000

// // --- PHYSICS ENGINE SETTINGS ---
// // Lower = Slower, Smoother. Higher = Faster.
// // 0.5 degrees per 20ms = 25 degrees per second (Very smooth/slow)
// // 1.0 degrees per 20ms = 50 degrees per second (Normal speed)
// #define MAX_SPEED_PER_TICK  0.8f 

// // --- DUMMY LED (Prevents Pin 2 Conflict) ---
// class NoOpLed : public Led {
// public:
//     void OnStateChanged() override { }
// };

// enum GestureType {
//     GESTURE_NONE,
//     GESTURE_NOD,
//     GESTURE_SHAKE,
//     GESTURE_CONFUSED, 
//     GESTURE_DANCE,
//     GESTURE_TILT,     
//     GESTURE_WIGGLE,
//     GESTURE_LOOK_UP,
//     GESTURE_LOOK_DOWN,
//     GESTURE_CENTER
// };

// struct ServoCommand {
//     GestureType type;
// };

// class FreenoveESP32S3Display : public WifiBoard {
// private:
//     Button boot_button_;
//     LcdDisplay *display_;
//     i2c_master_bus_handle_t codec_i2c_bus_;
    
//     // Logic Task (Receives commands)
//     QueueHandle_t logic_queue_;
//     TaskHandle_t logic_task_handle_;

//     // Physics Task (Moves motors smoothly)
//     TaskHandle_t physics_task_handle_;

//     // --- SHARED STATE (Protected) ---
//     // Where we want to be
//     float target_pan_ = 90.0f;
//     float target_tilt_ = 90.0f;
//     float target_roll_ = 90.0f;

//     // Where we actually are (Physics engine updates this)
//     float current_pan_ = 90.0f;
//     float current_tilt_ = 90.0f;
//     float current_roll_ = 90.0f;

//     // --- LOW LEVEL HARDWARE ---
//     uint32_t AngleToDuty(float angle) {
//         if (angle < 0.0f) angle = 0.0f;
//         if (angle > 180.0f) angle = 180.0f;
//         uint32_t pulse_us = SERVO_MIN_US + (uint32_t)((SERVO_MAX_US - SERVO_MIN_US) * angle / 180.0f);
//         uint32_t max_duty = (1 << SERVO_RESOLUTION) - 1;
//         return (pulse_us * max_duty) / SERVO_PERIOD_US;
//     }

//     void HardwareWrite(float pan, float tilt, float roll) {
//         ledc_set_duty(LEDC_LOW_SPEED_MODE, SERVO_CHANNEL_PAN, AngleToDuty(pan));
//         ledc_update_duty(LEDC_LOW_SPEED_MODE, SERVO_CHANNEL_PAN);
        
//         ledc_set_duty(LEDC_LOW_SPEED_MODE, SERVO_CHANNEL_TILT, AngleToDuty(tilt));
//         ledc_update_duty(LEDC_LOW_SPEED_MODE, SERVO_CHANNEL_TILT);

//         ledc_set_duty(LEDC_LOW_SPEED_MODE, SERVO_CHANNEL_ROLL, AngleToDuty(roll));
//         ledc_update_duty(LEDC_LOW_SPEED_MODE, SERVO_CHANNEL_ROLL);
//     }

//     // --- PHYSICS ENGINE TASK (Runs continuously) ---
//     // This makes violence impossible. It clamps movement speed.
//     static void PhysicsTask(void* arg) {
//         FreenoveESP32S3Display* board = (FreenoveESP32S3Display*)arg;
        
//         while(true) {
//             // Helper lambda to move 'current' towards 'target' by max_speed
//             auto smooth_step = [](float current, float target) -> float {
//                 float diff = target - current;
//                 if (fabs(diff) < MAX_SPEED_PER_TICK) return target; // Arrived
//                 if (diff > 0) return current + MAX_SPEED_PER_TICK;
//                 return current - MAX_SPEED_PER_TICK;
//             };

//             board->current_pan_ = smooth_step(board->current_pan_, board->target_pan_);
//             board->current_tilt_ = smooth_step(board->current_tilt_, board->target_tilt_);
//             board->current_roll_ = smooth_step(board->current_roll_, board->target_roll_);

//             board->HardwareWrite(board->current_pan_, board->current_tilt_, board->current_roll_);

//             // 50Hz Refresh Rate (Standard for Servos)
//             vTaskDelay(pdMS_TO_TICKS(20)); 
//         }
//     }

//     // --- HELPER: SET TARGETS ---
//     void SetTarget(float p, float t, float r) {
//         target_pan_ = p;
//         target_tilt_ = t;
//         target_roll_ = r;
//     }

//     // --- HIGH LEVEL GESTURE LOGIC ---
//     void ExecuteGesture(GestureType gesture) {
//         // NOTE: We only set TARGETS here. We never sleep for smoothness.
//         // We only sleep to hold a pose.
        
//         switch(gesture) {
//             case GESTURE_NOD:
//                 // Look Up
//                 SetTarget(90, 115, 90);
//                 vTaskDelay(pdMS_TO_TICKS(600)); // Wait for physics to get there
//                 // Look Down
//                 SetTarget(90, 75, 90);
//                 vTaskDelay(pdMS_TO_TICKS(600));
//                 // Center
//                 SetTarget(90, 90, 90);
//                 break;

//             case GESTURE_SHAKE:
//                 // Left
//                 SetTarget(125, 90, 90); // Exaggerated angle
//                 vTaskDelay(pdMS_TO_TICKS(500));
//                 // Right
//                 SetTarget(55, 90, 90);
//                 vTaskDelay(pdMS_TO_TICKS(500));
//                 // Center
//                 SetTarget(90, 90, 90);
//                 break;

//             case GESTURE_CONFUSED:
//                 // Cute Tilt: Pan(90), Tilt(Up 100), Roll(Side 135)
//                 SetTarget(90, 100, 135);
//                 vTaskDelay(pdMS_TO_TICKS(2000)); // Hold it!
//                 SetTarget(90, 90, 90);
//                 break;

//             case GESTURE_DANCE: {
//                 uint32_t start = esp_log_timestamp();
//                 // We update targets constantly, physics smooths the transitions
//                 while (esp_log_timestamp() - start < 5000) {
//                     float t = (esp_log_timestamp() - start) / 500.0f;
                    
//                     float p = 90 + (sin(t) * 35);      // Wide sway
//                     float y = 90 + (cos(t * 2) * 15);  // Bobbing
//                     float r = 90 + (sin(t) * 25);      // Rolling
                    
//                     SetTarget(p, y, r);
//                     vTaskDelay(pdMS_TO_TICKS(50)); // Update targets every 50ms
//                 }
//                 SetTarget(90, 90, 90);
//                 break;
//             }

//             case GESTURE_TILT: // Thinking
//                 SetTarget(120, 120, 110); // Look up and away
//                 vTaskDelay(pdMS_TO_TICKS(2000));
//                 SetTarget(90, 90, 90);
//                 break;

//             case GESTURE_WIGGLE: // Happy
//                 for(int i=0; i<3; i++) {
//                     SetTarget(110, 90, 110);
//                     vTaskDelay(pdMS_TO_TICKS(300));
//                     SetTarget(70, 90, 70);
//                     vTaskDelay(pdMS_TO_TICKS(300));
//                 }
//                 SetTarget(90, 90, 90);
//                 break;
            
//             case GESTURE_LOOK_DOWN: // Sad
//                 SetTarget(90, 60, 90);
//                 break; // Stays down

//             case GESTURE_LOOK_UP: // Surprised
//                 SetTarget(90, 120, 90);
//                 break;

//             default: // CENTER
//                 SetTarget(90, 90, 90);
//                 break;
//         }
//     }

//     static void LogicTask(void* arg) {
//         FreenoveESP32S3Display* board = (FreenoveESP32S3Display*)arg;
//         ServoCommand cmd;
//         while(true) {
//             if(xQueueReceive(board->logic_queue_, &cmd, portMAX_DELAY)) {
//                 board->ExecuteGesture(cmd.type);
//             }
//         }
//     }

//     void QueueGesture(GestureType type) {
//         ServoCommand cmd = { type };
//         xQueueSend(logic_queue_, &cmd, 0); 
//     }

// public:
//     FreenoveESP32S3Display() : boot_button_(BOOT_BUTTON_GPIO) {
//         InitializeI2c();
//         InitializeSpi();
//         InitializeLcdDisplay();
//         InitializeButtons();

//         // 1. Hardware Init
//         gpio_reset_pin(SERVO_PAN_PIN);
//         gpio_reset_pin(SERVO_TILT_PIN);
//         gpio_reset_pin(SERVO_ROLL_PIN);
//         vTaskDelay(pdMS_TO_TICKS(50));
//         InitializeServos();
        
//         // 2. Start Logic Task (Brain)
//         logic_queue_ = xQueueCreate(5, sizeof(ServoCommand));
//         xTaskCreate(LogicTask, "bot_logic", 4096, this, 5, &logic_task_handle_);
        
//         // 3. Start Physics Task (Muscles) - Priority 6 (High) to ensure smoothness
//         xTaskCreate(PhysicsTask, "bot_physics", 4096, this, 6, &physics_task_handle_);

//         // 4. Test
//         QueueGesture(GESTURE_CONFUSED);

//         InitializeTools(); 
//         GetBacklight()->SetBrightness(100);
//     }

//     void InitializeServos() {
//         ledc_timer_config_t timer_conf = {
//             .speed_mode = LEDC_LOW_SPEED_MODE,
//             .duty_resolution = SERVO_RESOLUTION,
//             .timer_num = SERVO_TIMER,
//             .freq_hz = SERVO_FREQ,
//             .clk_cfg = LEDC_AUTO_CLK
//         };
//         ledc_timer_config(&timer_conf);

//         auto config_channel = [&](int gpio, int channel) {
//             ledc_channel_config_t cfg = {
//                 .gpio_num = gpio,
//                 .speed_mode = LEDC_LOW_SPEED_MODE,
//                 .channel = (ledc_channel_t)channel,
//                 .intr_type = LEDC_INTR_DISABLE,
//                 .timer_sel = SERVO_TIMER,
//                 .duty = AngleToDuty(90),
//                 .hpoint = 0
//             };
//             ledc_channel_config(&cfg);
//         };

//         config_channel(SERVO_PAN_PIN, SERVO_CHANNEL_PAN);
//         config_channel(SERVO_TILT_PIN, SERVO_CHANNEL_TILT);
//         config_channel(SERVO_ROLL_PIN, SERVO_CHANNEL_ROLL);
//     }

//     void InitializeTools() {
//         auto& mcp = McpServer::GetInstance();

//         mcp.AddTool("self.express_emotion",
//             "Express emotion.",
//             PropertyList({
//                 Property("emotion", kPropertyTypeString, "happy, sad, excited, thinking, confused, neutral")
//             }),
//             [this](const PropertyList& props) -> ReturnValue {
//                 std::string emotion = props["emotion"].value<std::string>();
                
//                 if (emotion == "happy") {
//                     GetDisplay()->SetEmotion("happy");
//                     QueueGesture(GESTURE_NOD);
//                 } else if (emotion == "sad") {
//                     GetDisplay()->SetEmotion("sad");
//                     QueueGesture(GESTURE_LOOK_DOWN);
//                 } else if (emotion == "excited") {
//                     GetDisplay()->SetEmotion("music");
//                     QueueGesture(GESTURE_DANCE);
//                 } else if (emotion == "thinking") {
//                     GetDisplay()->SetEmotion("curious");
//                     QueueGesture(GESTURE_TILT);
//                 } else if (emotion == "confused") {
//                     GetDisplay()->SetEmotion("curious");
//                     QueueGesture(GESTURE_CONFUSED);
//                 } else {
//                     GetDisplay()->SetEmotion("neutral");
//                     QueueGesture(GESTURE_CENTER);
//                 }
//                 return "Expressed: " + emotion;
//             });
//     }

//     // --- OVERRIDES ---
//     virtual Led *GetLed() override { 
//         static NoOpLed led; 
//         return &led; 
//     }
    
//     virtual Backlight *GetBacklight() override { 
//         static PwmBacklight b(DISPLAY_BACKLIGHT_PIN, DISPLAY_BACKLIGHT_OUTPUT_INVERT); 
//         return &b; 
//     }

//     // --- STANDARD BOILERPLATE ---
//     void InitializeSpi() {
//         spi_bus_config_t buscfg = {};
//         buscfg.mosi_io_num = DISPLAY_MOSI_PIN;
//         buscfg.miso_io_num = DISPLAY_MIS0_PIN;
//         buscfg.sclk_io_num = DISPLAY_SCK_PIN;
//         buscfg.quadwp_io_num = GPIO_NUM_NC;
//         buscfg.quadhd_io_num = GPIO_NUM_NC;
//         buscfg.max_transfer_sz = DISPLAY_WIDTH * DISPLAY_HEIGHT * sizeof(uint16_t);
//         ESP_ERROR_CHECK(spi_bus_initialize(LCD_SPI_HOST, &buscfg, SPI_DMA_CH_AUTO));
//     }

//     void InitializeLcdDisplay() {
//         esp_lcd_panel_io_handle_t panel_io = nullptr;
//         esp_lcd_panel_handle_t panel = nullptr;
//         esp_lcd_panel_io_spi_config_t io_config = {};
//         io_config.cs_gpio_num = DISPLAY_CS_PIN;
//         io_config.dc_gpio_num = DISPLAY_DC_PIN;
//         io_config.spi_mode = DISPLAY_SPI_MODE;
//         io_config.pclk_hz = DISPLAY_SPI_SCLK_HZ;
//         io_config.trans_queue_depth = 10;
//         io_config.lcd_cmd_bits = 8;
//         io_config.lcd_param_bits = 8;
//         ESP_ERROR_CHECK(esp_lcd_new_panel_io_spi(LCD_SPI_HOST, &io_config, &panel_io));
        
//         esp_lcd_panel_dev_config_t panel_config = {};
//         panel_config.reset_gpio_num = DISPLAY_RST_PIN;
//         panel_config.rgb_ele_order = DISPLAY_RGB_ORDER;
//         panel_config.bits_per_pixel = 16;
//         ESP_ERROR_CHECK(esp_lcd_new_panel_ili9341(panel_io, &panel_config, &panel));
//         esp_lcd_panel_reset(panel);
//         esp_lcd_panel_init(panel);
//         esp_lcd_panel_invert_color(panel, DISPLAY_INVERT_COLOR);
//         esp_lcd_panel_swap_xy(panel, DISPLAY_SWAP_XY);
//         esp_lcd_panel_mirror(panel, DISPLAY_MIRROR_X, DISPLAY_MIRROR_Y);
        
//         display_ = new SpiLcdDisplay(panel_io, panel, 
//             DISPLAY_WIDTH, DISPLAY_HEIGHT, DISPLAY_OFFSET_X, DISPLAY_OFFSET_Y, 
//             DISPLAY_MIRROR_X, DISPLAY_MIRROR_Y, DISPLAY_SWAP_XY);
//     }

//     void InitializeI2c() {
//         i2c_master_bus_config_t i2c_bus_cfg = {
//             .i2c_port = AUDIO_CODEC_I2C_NUM,
//             .sda_io_num = AUDIO_CODEC_I2C_SDA_PIN,
//             .scl_io_num = AUDIO_CODEC_I2C_SCL_PIN,
//             .clk_source = I2C_CLK_SRC_DEFAULT,
//             .glitch_ignore_cnt = 7,
//             .intr_priority = 0,
//             .trans_queue_depth = 0,
//             .flags = { .enable_internal_pullup = 1 },
//         };
//         ESP_ERROR_CHECK(i2c_new_master_bus(&i2c_bus_cfg, &codec_i2c_bus_));
//     }

//     void InitializeButtons() {
//         boot_button_.OnClick([this]() {
//             auto &app = Application::GetInstance();
//             if (app.GetDeviceState() == kDeviceStateStarting && !WifiStation::GetInstance().IsConnected()) {
//                 ResetWifiConfiguration();
//             }
//             app.ToggleChatState();
//         });
//     }

//     virtual AudioCodec* GetAudioCodec() override {
//         static Es8311AudioCodec audio_codec(codec_i2c_bus_, AUDIO_CODEC_I2C_NUM,
//             AUDIO_INPUT_SAMPLE_RATE, AUDIO_OUTPUT_SAMPLE_RATE, AUDIO_I2S_GPIO_MCLK, 
//             AUDIO_I2S_GPIO_BCLK, AUDIO_I2S_GPIO_WS, AUDIO_I2S_GPIO_DOUT, 
//             AUDIO_I2S_GPIO_DIN, AUDIO_CODEC_PA_PIN, AUDIO_CODEC_ES8311_ADDR, 
//             true, true);
//         return &audio_codec;
//     }
    
//     virtual Display *GetDisplay() override { return display_; }
// };

// DECLARE_BOARD(FreenoveESP32S3Display);



// // sinusoidal smoother motion
// #include <driver/i2c_master.h>
// #include <driver/spi_common.h>
// #include <driver/ledc.h>
// #include <driver/gpio.h>
// #include <freertos/FreeRTOS.h>
// #include <freertos/task.h>
// #include <freertos/queue.h>
// #include <esp_log.h>
// #include <math.h>
// #include <vector>

// #include "esp_lcd_panel_vendor.h"
// #include "esp_lcd_panel_io.h"
// #include "esp_lcd_panel_ops.h"
// #include "wifi_station.h"
// #include "application.h"
// #include "audio/codecs/es8311_audio_codec.h"
// #include "button.h"
// #include "display/lcd_display.h"
// #include "led/single_led.h"
// #include "system_reset.h"
// #include "wifi_board.h"
// #include "mcp_server.h"
// #include "config.h"
// #include "esp_lcd_ili9341.h"

// #define TAG "KinematicBot"

// // --- PINS ---
// #define SERVO_PAN_PIN       GPIO_NUM_14
// #define SERVO_TILT_PIN      GPIO_NUM_21
// #define SERVO_ROLL_PIN      GPIO_NUM_3

// // --- CONFIG ---
// #define SERVO_FREQ          50
// #define SERVO_TIMER         LEDC_TIMER_3
// #define SERVO_MODE          LEDC_LOW_SPEED_MODE
// #define SERVO_RESOLUTION    LEDC_TIMER_14_BIT
// #define SERVO_CHANNEL_PAN   LEDC_CHANNEL_2
// #define SERVO_CHANNEL_TILT  LEDC_CHANNEL_3
// #define SERVO_CHANNEL_ROLL  LEDC_CHANNEL_4

// #define SERVO_MIN_US        500 
// #define SERVO_MAX_US        2500
// #define SERVO_PERIOD_US     20000

// // --- CONSTANTS ---
// #define PAN_MIN 0
// #define PAN_MAX 180
// #define TILT_MIN 0
// #define TILT_MAX 180 
// #define ROLL_MIN 0
// #define ROLL_MAX 180

// // Add more gesture types for richer animations
// enum GestureType {
//     GESTURE_IDLE,
//     GESTURE_NOD,
//     GESTURE_SHAKE,
//     GESTURE_CONFUSED,
//     GESTURE_THINKING,
//     GESTURE_EXCITED,
//     GESTURE_LOOK_TARGET,
//     GESTURE_DANCE,
//     GESTURE_SCAN_LR,
//     GESTURE_SCAN_UD
// };

// struct ServoCommand {
//     GestureType type;
//     float param1; // Used for generic target setting (e.g. Pan angle)
//     float param2; // Tilt
//     float param3; // Roll
// };

// // --- ASYNC SERVO CLASS ---
// // This handles the "Weighted Smooth" logic per motor
// // Enhanced ServoAxis with velocity limits and acceleration
// class ServoAxis {
// public:
//     float current_pos;
//     float target_pos;
//     float velocity;           // Current speed (degrees/frame)
//     float max_velocity;       // Speed limit
//     float acceleration;       // How fast velocity changes
//     float easing;
//     float snap_threshold; 

//     ServoAxis(float start_pos, float default_easing = 0.15f) {
//         current_pos = start_pos;
//         target_pos = start_pos;
//         velocity = 0.0f;
//         max_velocity = 3.0f;      // Max 3 degrees per 20ms frame
//         acceleration = 0.3f;       // Smooth acceleration
//         easing = default_easing;
//         snap_threshold = 0.5f;
//     }

//     void setTarget(float target, float new_easing = -1.0f, float speed_mult = 1.0f) {
//         target_pos = target;
//         if (new_easing > 0.0f) {
//             easing = new_easing;
//         }
//         // Allow speed override for urgent movements
//         max_velocity = 3.0f * speed_mult;
//     }

//     bool update() {
//         float error = target_pos - current_pos;
        
//         if (fabsf(error) <= snap_threshold) {
//             if (current_pos != target_pos) {
//                 current_pos = target_pos;
//                 velocity = 0.0f;
//                 return true;
//             }
//             velocity = 0.0f;
//             return false;
//         }

//         // Calculate desired velocity using easing
//         float desired_velocity = error * easing;
        
//         // Apply acceleration limits (prevents jerking)
//         float velocity_error = desired_velocity - velocity;
//         if (fabsf(velocity_error) > acceleration) {
//             velocity += copysignf(acceleration, velocity_error);
//         } else {
//             velocity = desired_velocity;
//         }
        
//         // Clamp to max velocity
//         if (fabsf(velocity) > max_velocity) {
//             velocity = copysignf(max_velocity, velocity);
//         }
        
//         current_pos += velocity;
//         return true;
//     }
    
//     bool isMoving() const {
//         return fabsf(velocity) > 0.1f || fabsf(target_pos - current_pos) > snap_threshold;
//     }
// };

// // Add animation state machine structure for complex sequences
// struct AnimationKeyframe {
//     float pan, tilt, roll;
//     float easing;
//     uint16_t duration_ms;
// };

// class NoOpLed : public Led { public: void OnStateChanged() override { } };

// class FreenoveESP32S3Display : public WifiBoard {
// private:
//     Button boot_button_;
//     LcdDisplay *display_;
//     i2c_master_bus_handle_t codec_i2c_bus_;
    
//     QueueHandle_t logic_queue_;
//     TaskHandle_t logic_task_handle_;

//     // --- NON-BLOCKING SERVO OBJECTS ---
//     ServoAxis pan_servo_{90.0f};
//     ServoAxis tilt_servo_{90.0f};
//     ServoAxis roll_servo_{90.0f};

//     // --- SYSTEM STATE ---
//     bool is_attached_ = false;
//     unsigned long last_move_time_ = 0;
    
//     // Animation Sequencer State
//     GestureType current_anim_ = GESTURE_IDLE;
//     int anim_step_ = 0;
//     unsigned long anim_timer_ = 0;

//     // --- HARDWARE INTERFACE ---
//     inline uint32_t AngleToDuty(float angle) {
//         if (angle < 0.0f) angle = 0.0f;
//         if (angle > 180.0f) angle = 180.0f;
//         uint32_t pulse_us = SERVO_MIN_US + (uint32_t)((SERVO_MAX_US - SERVO_MIN_US) * angle / 180.0f);
//         uint32_t max_duty = (1 << SERVO_RESOLUTION) - 1;
//         return (pulse_us * max_duty) / SERVO_PERIOD_US;
//     }

//     void AttachServos() {
//         if (is_attached_) return;
//         HardwareWrite(); // Re-apply current positions
//         is_attached_ = true;
//     }

//     void DetachServos() {
//         if (!is_attached_) return;
//         ledc_stop(SERVO_MODE, SERVO_CHANNEL_PAN, 0);
//         ledc_stop(SERVO_MODE, SERVO_CHANNEL_TILT, 0);
//         ledc_stop(SERVO_MODE, SERVO_CHANNEL_ROLL, 0);
//         is_attached_ = false;
//         // ESP_LOGI(TAG, "Sleep: Servos Detached");
//     }

//     void HardwareWrite() {
//         ledc_set_duty(SERVO_MODE, SERVO_CHANNEL_PAN, AngleToDuty(pan_servo_.current_pos));
//         ledc_update_duty(SERVO_MODE, SERVO_CHANNEL_PAN);
        
//         ledc_set_duty(SERVO_MODE, SERVO_CHANNEL_TILT, AngleToDuty(tilt_servo_.current_pos));
//         ledc_update_duty(SERVO_MODE, SERVO_CHANNEL_TILT);

//         ledc_set_duty(SERVO_MODE, SERVO_CHANNEL_ROLL, AngleToDuty(roll_servo_.current_pos));
//         ledc_update_duty(SERVO_MODE, SERVO_CHANNEL_ROLL);
//     }

//     // Enhanced animation system
//     std::vector<AnimationKeyframe> keyframes_;
//     int current_keyframe_ = -1;
    
//     // Pan servo special handling (it carries weight)
//     float pan_load_compensation_ = 0.7f;  // Reduce pan speed when tilting


//     // --- IMPROVED ANIMATION STATE MACHINE ---
//     void UpdateAnimationState() {
//         unsigned long now = xTaskGetTickCount() * portTICK_PERIOD_MS;

//         switch (current_anim_) {
//             case GESTURE_NOD:
//                 if (anim_step_ == 0) {
//                     tilt_servo_.setTarget(110, 0.2f, 1.5f); // Fast
//                     anim_step_++;
//                     anim_timer_ = now;
//                 }
//                 else if (anim_step_ == 1 && (now - anim_timer_ > 300)) {
//                     tilt_servo_.setTarget(75, 0.2f, 1.5f);
//                     anim_step_++;
//                     anim_timer_ = now;
//                 }
//                 else if (anim_step_ == 2 && (now - anim_timer_ > 300)) {
//                     tilt_servo_.setTarget(90, 0.15f);
//                     current_anim_ = GESTURE_IDLE;
//                 }
//                 break;

//             case GESTURE_SHAKE:
//                 if (anim_step_ == 0) {
//                     pan_servo_.setTarget(115, 0.18f);
//                     anim_step_++;
//                     anim_timer_ = now;
//                 }
//                 else if (anim_step_ == 1 && (now - anim_timer_ > 400)) {
//                     pan_servo_.setTarget(65, 0.18f);
//                     anim_step_++;
//                     anim_timer_ = now;
//                 }
//                 else if (anim_step_ == 2 && (now - anim_timer_ > 400)) {
//                     pan_servo_.setTarget(90, 0.12f);
//                     current_anim_ = GESTURE_IDLE;
//                 }
//                 break;
                
//             case GESTURE_CONFUSED:
//                 if (anim_step_ == 0) {
//                     // Simultaneous tilt + roll
//                     tilt_servo_.setTarget(95, 0.1f);
//                     roll_servo_.setTarget(115, 0.1f);
//                     anim_step_++;
//                     anim_timer_ = now;
//                 }
//                 else if (anim_step_ == 1 && (now - anim_timer_ > 1200)) {
//                     tilt_servo_.setTarget(90, 0.12f);
//                     roll_servo_.setTarget(90, 0.12f);
//                     current_anim_ = GESTURE_IDLE;
//                 }
//                 break;
                
//             case GESTURE_THINKING:
//                 if (anim_step_ == 0) {
//                     // Look up-left slowly
//                     pan_servo_.setTarget(105, 0.08f);
//                     tilt_servo_.setTarget(105, 0.08f);
//                     anim_step_++;
//                     anim_timer_ = now;
//                 }
//                 else if (anim_step_ == 1 && (now - anim_timer_ > 1800)) {
//                     pan_servo_.setTarget(90, 0.1f);
//                     tilt_servo_.setTarget(90, 0.1f);
//                     current_anim_ = GESTURE_IDLE;
//                 }
//                 break;
                
//             case GESTURE_EXCITED:
//                 // Quick nod sequence
//                 if (anim_step_ == 0) {
//                     tilt_servo_.setTarget(105, 0.25f, 2.0f);
//                     anim_step_++;
//                     anim_timer_ = now;
//                 }
//                 else if (anim_step_ == 1 && (now - anim_timer_ > 200)) {
//                     tilt_servo_.setTarget(85, 0.25f, 2.0f);
//                     anim_step_++;
//                     anim_timer_ = now;
//                 }
//                 else if (anim_step_ == 2 && (now - anim_timer_ > 200)) {
//                     tilt_servo_.setTarget(100, 0.25f, 2.0f);
//                     anim_step_++;
//                     anim_timer_ = now;
//                 }
//                 else if (anim_step_ == 3 && (now - anim_timer_ > 200)) {
//                     tilt_servo_.setTarget(90, 0.15f);
//                     current_anim_ = GESTURE_IDLE;
//                 }
//                 break;
                
//             case GESTURE_DANCE:
//                 // 3-axis choreography
//                 if (anim_step_ == 0) {
//                     pan_servo_.setTarget(105, 0.15f);
//                     tilt_servo_.setTarget(85, 0.15f);
//                     roll_servo_.setTarget(105, 0.15f);
//                     anim_step_++;
//                     anim_timer_ = now;
//                 }
//                 else if (anim_step_ == 1 && (now - anim_timer_ > 500)) {
//                     pan_servo_.setTarget(75, 0.15f);
//                     tilt_servo_.setTarget(95, 0.15f);
//                     roll_servo_.setTarget(75, 0.15f);
//                     anim_step_++;
//                     anim_timer_ = now;
//                 }
//                 else if (anim_step_ == 2 && (now - anim_timer_ > 500)) {
//                     pan_servo_.setTarget(105, 0.15f);
//                     tilt_servo_.setTarget(85, 0.15f);
//                     roll_servo_.setTarget(105, 0.15f);
//                     anim_step_++;
//                     anim_timer_ = now;
//                 }
//                 else if (anim_step_ == 3 && (now - anim_timer_ > 500)) {
//                     pan_servo_.setTarget(90, 0.12f);
//                     tilt_servo_.setTarget(90, 0.12f);
//                     roll_servo_.setTarget(90, 0.12f);
//                     current_anim_ = GESTURE_IDLE;
//                 }
//                 break;
                
//             case GESTURE_SCAN_LR:
//                 if (anim_step_ == 0) {
//                     pan_servo_.setTarget(120, 0.12f);
//                     anim_step_++;
//                     anim_timer_ = now;
//                 }
//                 else if (anim_step_ == 1 && (now - anim_timer_ > 800)) {
//                     pan_servo_.setTarget(60, 0.12f);
//                     anim_step_++;
//                     anim_timer_ = now;
//                 }
//                 else if (anim_step_ == 2 && (now - anim_timer_ > 800)) {
//                     pan_servo_.setTarget(90, 0.12f);
//                     current_anim_ = GESTURE_IDLE;
//                 }
//                 break;
                
//             case GESTURE_SCAN_UD:
//                 if (anim_step_ == 0) {
//                     tilt_servo_.setTarget(110, 0.12f);
//                     anim_step_++;
//                     anim_timer_ = now;
//                 }
//                 else if (anim_step_ == 1 && (now - anim_timer_ > 700)) {
//                     tilt_servo_.setTarget(70, 0.12f);
//                     anim_step_++;
//                     anim_timer_ = now;
//                 }
//                 else if (anim_step_ == 2 && (now - anim_timer_ > 700)) {
//                     tilt_servo_.setTarget(90, 0.12f);
//                     current_anim_ = GESTURE_IDLE;
//                 }
//                 break;
                
//             case GESTURE_IDLE:
//             default:
//                 break;
//         }
//     }

//     // --- IMPROVED PHYSICS UPDATE ---
//     // --- IMPROVED PHYSICS UPDATE ---
//     bool UpdatePhysics() {  // Changed from void to bool
//         bool moving = false;
        
//         // Apply load compensation: slow pan down if other axes are moving
//         float pan_compensation = 1.0f;
//         if (tilt_servo_.isMoving() || roll_servo_.isMoving()) {
//             pan_compensation = pan_load_compensation_;
//         }
        
//         // Update each axis
//         moving |= pan_servo_.update();
//         moving |= tilt_servo_.update();
//         moving |= roll_servo_.update();
        
//         // Apply compensation after update
//         if (pan_compensation < 1.0f) {
//             pan_servo_.max_velocity *= pan_compensation;
//         }
        
//         return moving;  // Now correctly returns bool
//     }

//     // --- ENHANCED MAIN LOOP ---
//     static void LogicTask(void* arg) {
//         FreenoveESP32S3Display* board = (FreenoveESP32S3Display*)arg;
//         ServoCommand cmd;

//         const TickType_t kTickRate = pdMS_TO_TICKS(20); // 50Hz
//         TickType_t last_wake_time = xTaskGetTickCount();
        
//         bool motion_detected = false;

//         while(true) {
//             // 1. INPUT: Check for new commands
//             if(xQueueReceive(board->logic_queue_, &cmd, 0) == pdTRUE) {
//                 board->AttachServos();
//                 board->last_move_time_ = xTaskGetTickCount() * portTICK_PERIOD_MS;
                
//                 ESP_LOGI(TAG, "Command: type=%d, params=(%.1f, %.1f, %.1f)", 
//                          cmd.type, cmd.param1, cmd.param2, cmd.param3);
                
//                 if (cmd.type == GESTURE_LOOK_TARGET) {
//                     board->current_anim_ = GESTURE_IDLE; // Cancel animation
//                     board->pan_servo_.setTarget(cmd.param1, 0.15f);
//                     board->tilt_servo_.setTarget(cmd.param2, 0.15f);
//                     board->roll_servo_.setTarget(cmd.param3, 0.15f);
//                 } else {
//                     board->current_anim_ = cmd.type;
//                     board->anim_step_ = 0;
//                     board->anim_timer_ = 0;
//                 }
//             }

//             // 2. LOGIC: Update animation state machine
//             board->UpdateAnimationState();

//             // 3. PHYSICS: Update servo positions with load compensation
//             bool moving = board->UpdatePhysics();

//             // 4. OUTPUT: Write to hardware if changed
//             if (moving) {
//                 board->HardwareWrite();
//                 board->last_move_time_ = xTaskGetTickCount() * portTICK_PERIOD_MS;
//                 motion_detected = true;
//             } else if (motion_detected) {
//                 // Just stopped - log it once
//                 ESP_LOGI(TAG, "Motion complete: pan=%.1f, tilt=%.1f, roll=%.1f",
//                          board->pan_servo_.current_pos,
//                          board->tilt_servo_.current_pos,
//                          board->roll_servo_.current_pos);
//                 motion_detected = false;
//             }

//             // 5. POWER SAVE: Auto-detach after idle period
//             if (!moving && board->is_attached_) {
//                 unsigned long now = xTaskGetTickCount() * portTICK_PERIOD_MS;
//                 if (now - board->last_move_time_ > 1500) { // 1.5s idle timeout
//                     board->DetachServos();
//                 }
//             }

//             // 6. TIMING: Maintain 50Hz loop
//             vTaskDelayUntil(&last_wake_time, kTickRate);
//         }
//     }

// public:
//     FreenoveESP32S3Display() : boot_button_(BOOT_BUTTON_GPIO) {
//         InitializeI2c();
//         InitializeSpi();
//         InitializeLcdDisplay();
//         InitializeButtons();

//         gpio_reset_pin(SERVO_PAN_PIN);
//         gpio_reset_pin(SERVO_TILT_PIN);
//         gpio_reset_pin(SERVO_ROLL_PIN);
        
//         InitializeServos();
        
//         logic_queue_ = xQueueCreate(10, sizeof(ServoCommand));
//         xTaskCreatePinnedToCore(LogicTask, "bot_brain", 4096, this, 10, &logic_task_handle_, 1);
        
//         InitializeTools(); 
//         GetBacklight()->SetBrightness(100);
        
//         // Initial Nod
//         ServoCommand cmd = { GESTURE_NOD, 0, 0, 0 };
//         xQueueSend(logic_queue_, &cmd, 0);
//     }

//     void InitializeServos() {
//         ledc_timer_config_t timer_conf = {
//             .speed_mode = SERVO_MODE,
//             .duty_resolution = SERVO_RESOLUTION,
//             .timer_num = SERVO_TIMER,
//             .freq_hz = SERVO_FREQ,
//             .clk_cfg = LEDC_AUTO_CLK
//         };
//         ledc_timer_config(&timer_conf);

//         auto config_channel = [&](int gpio, int channel) {
//             ledc_channel_config_t cfg = {
//                 .gpio_num = gpio,
//                 .speed_mode = SERVO_MODE,
//                 .channel = (ledc_channel_t)channel,
//                 .intr_type = LEDC_INTR_DISABLE,
//                 .timer_sel = SERVO_TIMER,
//                 .duty = AngleToDuty(90),
//                 .hpoint = 0
//             };
//             ledc_channel_config(&cfg);
//         };

//         config_channel(SERVO_PAN_PIN, SERVO_CHANNEL_PAN);
//         config_channel(SERVO_TILT_PIN, SERVO_CHANNEL_TILT);
//         config_channel(SERVO_ROLL_PIN, SERVO_CHANNEL_ROLL);
        
//         is_attached_ = true;
//     }

//     // --- IMPROVED MCP TOOLS ---
//     // Fix the MCP tool - remove .contains() check
//     void InitializeTools() {
//         auto& mcp = McpServer::GetInstance();

//         mcp.AddTool("self.move_head",
//             "Move head precisely. Direction: left|right|up|down|center|scan_lr|scan_ud. Intensity: 0-100",
//             PropertyList({
//                 Property("direction", kPropertyTypeString, std::string("center")),
//                 Property("intensity", kPropertyTypeInteger, 70, 0, 100)
//             }),
//             [this](const PropertyList& props) -> ReturnValue {
//                 std::string dir = props["direction"].value<std::string>();
//                 int val = props["intensity"].value<int>(); // Just read it directly
//                 float intensity = (float)val / 100.0f;
                
//                 ServoCommand cmd;
//                 cmd.type = GESTURE_LOOK_TARGET;
//                 cmd.param1 = 90; // pan
//                 cmd.param2 = 90; // tilt
//                 cmd.param3 = 90; // roll
                
//                 if (dir == "left") {
//                     cmd.param1 = 90 + (35 * intensity);
//                 } else if (dir == "right") {
//                     cmd.param1 = 90 - (35 * intensity);
//                 } else if (dir == "up") {
//                     cmd.param2 = 90 + (25 * intensity);
//                 } else if (dir == "down") {
//                     cmd.param2 = 90 - (25 * intensity);
//                 } else if (dir == "scan_lr") {
//                     cmd.type = GESTURE_SCAN_LR;
//                 } else if (dir == "scan_ud") {
//                     cmd.type = GESTURE_SCAN_UD;
//                 }
                
//                 xQueueSend(logic_queue_, &cmd, portMAX_DELAY);
//                 return ReturnValue("Moving " + dir);
//             });
            
//         mcp.AddTool("self.express_emotion",
//             "Express emotion: happy|sad|excited|thinking|confused|surprised|neutral",
//             PropertyList({
//                 Property("emotion", kPropertyTypeString, std::string("neutral"))
//             }),
//             [this](const PropertyList& props) -> ReturnValue {
//                 std::string emotion = props["emotion"].value<std::string>();
//                 ServoCommand cmd = { GESTURE_IDLE, 90, 90, 90 };
//                 const char* face = "neutral";

//                 if (emotion == "happy") {
//                     cmd.type = GESTURE_DANCE;
//                     face = "happy";
//                 } else if (emotion == "sad") {
//                     cmd.type = GESTURE_LOOK_TARGET;
//                     cmd.param2 = 75; // Look down
//                     face = "sad";
//                 } else if (emotion == "excited") {
//                     cmd.type = GESTURE_EXCITED;
//                     face = "music";
//                 } else if (emotion == "thinking") {
//                     cmd.type = GESTURE_THINKING;
//                     face = "curious";
//                 } else if (emotion == "confused") {
//                     cmd.type = GESTURE_CONFUSED;
//                     face = "curious";
//                 } else if (emotion == "surprised") {
//                     cmd.type = GESTURE_EXCITED; // Quick reaction
//                     face = "happy";
//                 }

//                 GetDisplay()->SetEmotion(face);
//                 xQueueSend(logic_queue_, &cmd, 0);
                
//                 return ReturnValue("Expressed " + emotion);
//             });
            
//         // NEW: Fine position control for advanced use
//         mcp.AddTool("self.set_position",
//             "Set exact servo angles. Range 0-180 for each axis.",
//             PropertyList({
//                 Property("pan", kPropertyTypeInteger, 90, 0, 180),
//                 Property("tilt", kPropertyTypeInteger, 90, 0, 180),
//                 Property("roll", kPropertyTypeInteger, 90, 0, 180)
//             }),
//             [this](const PropertyList& props) -> ReturnValue {
//                 ServoCommand cmd;
//                 cmd.type = GESTURE_LOOK_TARGET;
//                 cmd.param1 = props["pan"].value<int>();
//                 cmd.param2 = props["tilt"].value<int>();
//                 cmd.param3 = props["roll"].value<int>();
                
//                 xQueueSend(logic_queue_, &cmd, portMAX_DELAY);
                
//                 return ReturnValue("Position set");
//             });
//     }

//     virtual Led *GetLed() override { static NoOpLed led; return &led; }
//     virtual Backlight *GetBacklight() override { static PwmBacklight b(DISPLAY_BACKLIGHT_PIN, DISPLAY_BACKLIGHT_OUTPUT_INVERT); return &b; }

//     // --- BOILERPLATE ---
//     void InitializeSpi() {
//         spi_bus_config_t buscfg = {};
//         buscfg.mosi_io_num = DISPLAY_MOSI_PIN;
//         buscfg.miso_io_num = DISPLAY_MIS0_PIN;
//         buscfg.sclk_io_num = DISPLAY_SCK_PIN;
//         buscfg.quadwp_io_num = GPIO_NUM_NC;
//         buscfg.quadhd_io_num = GPIO_NUM_NC;
//         buscfg.max_transfer_sz = DISPLAY_WIDTH * DISPLAY_HEIGHT * sizeof(uint16_t);
//         ESP_ERROR_CHECK(spi_bus_initialize(LCD_SPI_HOST, &buscfg, SPI_DMA_CH_AUTO));
//     }

//     void InitializeLcdDisplay() {
//         esp_lcd_panel_io_handle_t panel_io = nullptr;
//         esp_lcd_panel_handle_t panel = nullptr;
//         esp_lcd_panel_io_spi_config_t io_config = {};
//         io_config.cs_gpio_num = DISPLAY_CS_PIN;
//         io_config.dc_gpio_num = DISPLAY_DC_PIN;
//         io_config.spi_mode = DISPLAY_SPI_MODE;
//         io_config.pclk_hz = DISPLAY_SPI_SCLK_HZ;
//         io_config.trans_queue_depth = 10;
//         io_config.lcd_cmd_bits = 8;
//         io_config.lcd_param_bits = 8;
//         ESP_ERROR_CHECK(esp_lcd_new_panel_io_spi(LCD_SPI_HOST, &io_config, &panel_io));
        
//         esp_lcd_panel_dev_config_t panel_config = {};
//         panel_config.reset_gpio_num = DISPLAY_RST_PIN;
//         panel_config.rgb_ele_order = DISPLAY_RGB_ORDER;
//         panel_config.bits_per_pixel = 16;
//         ESP_ERROR_CHECK(esp_lcd_new_panel_ili9341(panel_io, &panel_config, &panel));
//         esp_lcd_panel_reset(panel);
//         esp_lcd_panel_init(panel);
//         esp_lcd_panel_invert_color(panel, DISPLAY_INVERT_COLOR);
//         esp_lcd_panel_swap_xy(panel, DISPLAY_SWAP_XY);
//         esp_lcd_panel_mirror(panel, DISPLAY_MIRROR_X, DISPLAY_MIRROR_Y);
        
//         display_ = new SpiLcdDisplay(panel_io, panel, 
//             DISPLAY_WIDTH, DISPLAY_HEIGHT, DISPLAY_OFFSET_X, DISPLAY_OFFSET_Y, 
//             DISPLAY_MIRROR_X, DISPLAY_MIRROR_Y, DISPLAY_SWAP_XY);
//     }

//     void InitializeI2c() {
//         i2c_master_bus_config_t i2c_bus_cfg = {
//             .i2c_port = AUDIO_CODEC_I2C_NUM,
//             .sda_io_num = AUDIO_CODEC_I2C_SDA_PIN,
//             .scl_io_num = AUDIO_CODEC_I2C_SCL_PIN,
//             .clk_source = I2C_CLK_SRC_DEFAULT,
//             .glitch_ignore_cnt = 7,
//             .intr_priority = 0,
//             .trans_queue_depth = 0,
//             .flags = { .enable_internal_pullup = 1 },
//         };
//         ESP_ERROR_CHECK(i2c_new_master_bus(&i2c_bus_cfg, &codec_i2c_bus_));
//     }

//     void InitializeButtons() {
//         boot_button_.OnClick([this]() {
//             auto &app = Application::GetInstance();
//             if (app.GetDeviceState() == kDeviceStateStarting && !WifiStation::GetInstance().IsConnected()) {
//                 ResetWifiConfiguration();
//             }
//             app.ToggleChatState();
//         });
//     }

//     virtual AudioCodec* GetAudioCodec() override {
//         static Es8311AudioCodec audio_codec(codec_i2c_bus_, AUDIO_CODEC_I2C_NUM,
//             AUDIO_INPUT_SAMPLE_RATE, AUDIO_OUTPUT_SAMPLE_RATE, AUDIO_I2S_GPIO_MCLK, 
//             AUDIO_I2S_GPIO_BCLK, AUDIO_I2S_GPIO_WS, AUDIO_I2S_GPIO_DOUT, 
//             AUDIO_I2S_GPIO_DIN, AUDIO_CODEC_PA_PIN, AUDIO_CODEC_ES8311_ADDR, 
//             true, true);
//         return &audio_codec;
//     }
    
//     virtual Display *GetDisplay() override { return display_; }
// };

// DECLARE_BOARD(FreenoveESP32S3Display);


//choreography much better, 3 motors, 1 motion per chat
#include <driver/i2c_master.h>
#include <driver/spi_common.h>
#include <driver/ledc.h>
#include <driver/gpio.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include <freertos/queue.h>
#include <esp_log.h>
#include <math.h>
#include <vector>
#include <string>

#include "esp_lcd_panel_vendor.h"
#include "esp_lcd_panel_io.h"
#include "esp_lcd_panel_ops.h"
#include "wifi_station.h"
#include "application.h"
#include "audio/codecs/es8311_audio_codec.h"
#include "button.h"
#include "display/lcd_display.h"
#include "led/single_led.h"
#include "system_reset.h"
#include "wifi_board.h"
#include "mcp_server.h"
#include "config.h"
#include "esp_lcd_ili9341.h"

#define TAG "KinematicBot"

// --- PINS ---
#define SERVO_PAN_PIN       GPIO_NUM_14
#define SERVO_TILT_PIN      GPIO_NUM_21
// CHANGED: Roll motor now on Pin 3
#define SERVO_ROLL_PIN      GPIO_NUM_3  

// --- CONFIG ---
#define SERVO_FREQ          50
#define SERVO_TIMER         LEDC_TIMER_3
#define SERVO_MODE          LEDC_LOW_SPEED_MODE
#define SERVO_RESOLUTION    LEDC_TIMER_14_BIT
#define SERVO_CHANNEL_PAN   LEDC_CHANNEL_2
#define SERVO_CHANNEL_TILT  LEDC_CHANNEL_3
#define SERVO_CHANNEL_ROLL  LEDC_CHANNEL_4

#define SERVO_MIN_US        500 
#define SERVO_MAX_US        2500
#define SERVO_PERIOD_US     20000

// --- ENUMS & STRUCTS ---
enum GestureType {
    GESTURE_IDLE,
    GESTURE_NOD,
    GESTURE_SHAKE,
    GESTURE_SCAN,
    GESTURE_LOOK_TARGET,
    GESTURE_CHOREOGRAPHY  // NEW
};

struct ChoreographyStep {
    float pan;
    float tilt;
    float roll;
    int duration_ms;
    float easing;
};

struct ServoCommand {
    GestureType type;
    float param1;
    float param2;
    float param3;
    
    // NEW: For complex sequences
    std::vector<ChoreographyStep>* sequence;
    bool owns_sequence;
    
    ServoCommand() : type(GESTURE_IDLE), param1(0), param2(0), param3(0), sequence(nullptr), owns_sequence(false) {}
    
    // Safety: If we own the sequence, delete it when the command is destroyed
    // Note: In a real queue copy, you need to be careful with ownership. 
    // For simplicity here, we assume the producer passes ownership to the consumer.
};

// --- ASYNC SERVO CLASS ---
class ServoAxis {
public:
    float current_pos;
    float target_pos;
    float easing;
    float snap_threshold; 

    ServoAxis(float start_pos, float default_easing = 0.1f) {
        current_pos = start_pos;
        target_pos = start_pos;
        easing = default_easing;
        snap_threshold = 0.5f;
    }

    void setTarget(float target, float new_easing = -1.0f) {
        target_pos = target;
        if (new_easing > 0.0f) {
            easing = new_easing;
        }
    }

    bool update() {
        if (fabs(current_pos - target_pos) <= snap_threshold) {
            if (current_pos != target_pos) {
                current_pos = target_pos; 
                return true;
            }
            return false; 
        }
        current_pos = (current_pos * (1.0f - easing)) + (target_pos * easing);
        return true;
    }
};

class NoOpLed : public Led { public: void OnStateChanged() override { } };

class FreenoveESP32S3Display : public WifiBoard {
private:
    Button boot_button_;
    LcdDisplay *display_;
    i2c_master_bus_handle_t codec_i2c_bus_;
    
    QueueHandle_t logic_queue_;
    TaskHandle_t logic_task_handle_;

    // Servos
    ServoAxis pan_servo_{90.0f};
    ServoAxis tilt_servo_{90.0f};
    ServoAxis roll_servo_{90.0f};

    // System State
    bool is_attached_ = false;
    unsigned long last_move_time_ = 0;
    
    // Simple Animation State (Legacy)
    GestureType current_anim_ = GESTURE_IDLE;
    int anim_step_ = 0;
    unsigned long anim_timer_ = 0;

    // --- HARDWARE ---
    inline uint32_t AngleToDuty(float angle) {
        if (angle < 0.0f) angle = 0.0f;
        if (angle > 180.0f) angle = 180.0f;
        uint32_t pulse_us = SERVO_MIN_US + (uint32_t)((SERVO_MAX_US - SERVO_MIN_US) * angle / 180.0f);
        uint32_t max_duty = (1 << SERVO_RESOLUTION) - 1;
        return (pulse_us * max_duty) / SERVO_PERIOD_US;
    }

    void AttachServos() {
        if (is_attached_) return;
        HardwareWrite(); 
        is_attached_ = true;
    }

    void DetachServos() {
        if (!is_attached_) return;
        ledc_stop(SERVO_MODE, SERVO_CHANNEL_PAN, 0);
        ledc_stop(SERVO_MODE, SERVO_CHANNEL_TILT, 0);
        ledc_stop(SERVO_MODE, SERVO_CHANNEL_ROLL, 0);
        is_attached_ = false;
    }

    void HardwareWrite() {
        ledc_set_duty(SERVO_MODE, SERVO_CHANNEL_PAN, AngleToDuty(pan_servo_.current_pos));
        ledc_update_duty(SERVO_MODE, SERVO_CHANNEL_PAN);
        
        ledc_set_duty(SERVO_MODE, SERVO_CHANNEL_TILT, AngleToDuty(tilt_servo_.current_pos));
        ledc_update_duty(SERVO_MODE, SERVO_CHANNEL_TILT);

        ledc_set_duty(SERVO_MODE, SERVO_CHANNEL_ROLL, AngleToDuty(roll_servo_.current_pos));
        ledc_update_duty(SERVO_MODE, SERVO_CHANNEL_ROLL);
    }

    // --- PHYSICS ENGINE ---
    // Returns true if any servo moved
    bool UpdatePhysics() {
        bool moving = false;
        moving |= pan_servo_.update();
        moving |= tilt_servo_.update();
        moving |= roll_servo_.update();
        return moving;
    }

    // --- CHOREOGRAPHY ENGINE ---
    void ExecuteChoreography(const std::vector<ChoreographyStep>& steps) {
        ESP_LOGI(TAG, "Starting choreography: %d steps", steps.size());
        
        for (size_t i = 0; i < steps.size(); i++) {
            const auto& step = steps[i];
            
            // Set targets
            pan_servo_.setTarget(step.pan, step.easing);
            tilt_servo_.setTarget(step.tilt, step.easing);
            roll_servo_.setTarget(step.roll, step.easing);
            
            // Wait for duration while UPDATING PHYSICS
            unsigned long step_start = xTaskGetTickCount() * portTICK_PERIOD_MS;
            unsigned long now = step_start;
            
            while ((now - step_start) < step.duration_ms) {
                // IMPORTANT: We must update the servo positions during the wait!
                // Otherwise easing won't work.
                if (UpdatePhysics()) {
                    HardwareWrite();
                }
                
                vTaskDelay(pdMS_TO_TICKS(20)); // 50Hz update rate
                now = xTaskGetTickCount() * portTICK_PERIOD_MS;
            }
        }
        ESP_LOGI(TAG, "Choreography complete");
    }

    void UpdateAnimationState() {
        unsigned long now = xTaskGetTickCount() * portTICK_PERIOD_MS;
        switch (current_anim_) {
            case GESTURE_NOD:
                if (anim_step_ == 0) { tilt_servo_.setTarget(120, 0.15f); anim_step_++; anim_timer_ = now; }
                else if (anim_step_ == 1 && (now - anim_timer_ > 200)) { tilt_servo_.setTarget(70, 0.15f); anim_step_++; anim_timer_ = now; }
                else if (anim_step_ == 2 && (now - anim_timer_ > 200)) { tilt_servo_.setTarget(90, 0.1f); current_anim_ = GESTURE_IDLE; }
                break;
            case GESTURE_SHAKE:
                if (anim_step_ == 0) { pan_servo_.setTarget(120, 0.15f); anim_step_++; anim_timer_ = now; }
                else if (anim_step_ == 1 && (now - anim_timer_ > 250)) { pan_servo_.setTarget(60, 0.15f); anim_step_++; anim_timer_ = now; }
                else if (anim_step_ == 2 && (now - anim_timer_ > 250)) { pan_servo_.setTarget(90, 0.1f); current_anim_ = GESTURE_IDLE; }
                break;
            default: break;
        }
    }

    static void LogicTask(void* arg) {
        FreenoveESP32S3Display* board = (FreenoveESP32S3Display*)arg;
        ServoCommand cmd;
        const TickType_t kTickRate = pdMS_TO_TICKS(20);
        TickType_t last_wake_time = xTaskGetTickCount();

        while(true) {
            // Check Queue
            if(xQueueReceive(board->logic_queue_, &cmd, 0) == pdTRUE) {
                board->AttachServos();
                board->last_move_time_ = xTaskGetTickCount() * portTICK_PERIOD_MS;

                if (cmd.type == GESTURE_CHOREOGRAPHY && cmd.sequence) {
                    // Execute Complex Sequence
                    board->ExecuteChoreography(*cmd.sequence);
                    // Cleanup
                    if(cmd.owns_sequence) delete cmd.sequence;
                }
                else if (cmd.type == GESTURE_LOOK_TARGET) {
                    board->current_anim_ = GESTURE_IDLE;
                    board->pan_servo_.setTarget(cmd.param1);
                    board->tilt_servo_.setTarget(cmd.param2);
                    board->roll_servo_.setTarget(cmd.param3);
                }
                else {
                    board->current_anim_ = cmd.type;
                    board->anim_step_ = 0;
                    board->anim_timer_ = 0;
                }
            }

            // Update Logic
            board->UpdateAnimationState();
            
            // Update Physics
            bool moving = board->UpdatePhysics();
            if (moving) {
                board->HardwareWrite();
                board->last_move_time_ = xTaskGetTickCount() * portTICK_PERIOD_MS;
            }

            // Power Save
            if (!moving && board->is_attached_) {
                if ((xTaskGetTickCount() * portTICK_PERIOD_MS) - board->last_move_time_ > 1000) {
                    board->DetachServos();
                }
            }

            vTaskDelayUntil(&last_wake_time, kTickRate);
        }
    }

public:
    FreenoveESP32S3Display() : boot_button_(BOOT_BUTTON_GPIO) {
        InitializeI2c();
        InitializeSpi();
        InitializeLcdDisplay();
        InitializeButtons();

        // Hardware Init
        gpio_reset_pin(SERVO_PAN_PIN);
        gpio_reset_pin(SERVO_TILT_PIN);
        gpio_reset_pin(SERVO_ROLL_PIN);
        
        InitializeServos();
        
        logic_queue_ = xQueueCreate(10, sizeof(ServoCommand));
        xTaskCreatePinnedToCore(LogicTask, "bot_brain", 4096, this, 10, &logic_task_handle_, 1);
        
        InitializeTools(); 
        GetBacklight()->SetBrightness(100);
        
        // Hello Nod
        ServoCommand cmd; cmd.type = GESTURE_NOD;
        xQueueSend(logic_queue_, &cmd, 0);
    }

    void InitializeServos() {
        ledc_timer_config_t timer_conf = {
            .speed_mode = SERVO_MODE,
            .duty_resolution = SERVO_RESOLUTION,
            .timer_num = SERVO_TIMER,
            .freq_hz = SERVO_FREQ,
            .clk_cfg = LEDC_AUTO_CLK
        };
        ledc_timer_config(&timer_conf);

        auto config_channel = [&](int gpio, int channel) {
            ledc_channel_config_t cfg = {
                .gpio_num = gpio,
                .speed_mode = SERVO_MODE,
                .channel = (ledc_channel_t)channel,
                .intr_type = LEDC_INTR_DISABLE,
                .timer_sel = SERVO_TIMER,
                .duty = AngleToDuty(90),
                .hpoint = 0
            };
            ledc_channel_config(&cfg);
        };

        config_channel(SERVO_PAN_PIN, SERVO_CHANNEL_PAN);
        config_channel(SERVO_TILT_PIN, SERVO_CHANNEL_TILT);
        config_channel(SERVO_ROLL_PIN, SERVO_CHANNEL_ROLL);
        
        is_attached_ = true;
    }

    void InitializeTools() {
        auto& mcp = McpServer::GetInstance();

        // --- 1. CHOREOGRAPHY TOOL (NEW) ---
        mcp.AddTool("self.perform_choreography",
            "Execute a complex movement sequence. Options: greet, scan, dance, thinking_pose, surprised_look",
            PropertyList({
                Property("sequence_name", kPropertyTypeString, std::string("greet"))
            }),
            [this](const PropertyList& props) -> ReturnValue {
                std::string seq_name = props["sequence_name"].value<std::string>();
                auto* steps = new std::vector<ChoreographyStep>();

                if (seq_name == "greet") {
                    // Nod + Sweep
                    steps->push_back({90, 105, 90, 300, 0.2f});
                    steps->push_back({95, 90, 95, 400, 0.15f});
                    steps->push_back({85, 90, 85, 400, 0.15f});
                    steps->push_back({90, 90, 90, 300, 0.15f});
                }
                else if (seq_name == "scan") {
                    // Surveillance mode
                    steps->push_back({120, 95, 90, 800, 0.12f});
                    steps->push_back({60, 95, 90, 1200, 0.12f});
                    steps->push_back({60, 105, 90, 600, 0.12f});
                    steps->push_back({120, 105, 90, 1200, 0.12f});
                    steps->push_back({90, 90, 90, 600, 0.15f});
                }
                else if (seq_name == "dance") {
                    // Figure-8 with Roll
                    for(int i = 0; i < 4; i++) {
                        float p = (i%2==0) ? 110 : 70;
                        float t = (i%2==0) ? 80 : 100;
                        float r = (i%2==0) ? 110 : 70;
                        steps->push_back({p, t, r, 400, 0.18f});
                    }
                    steps->push_back({90, 90, 90, 500, 0.15f});
                }
                else if (seq_name == "thinking_pose") {
                    // Look up and tilt head
                    steps->push_back({105, 105, 85, 1500, 0.08f});
                    steps->push_back({105, 105, 85, 2000, 0.05f}); // Hold
                    steps->push_back({90, 90, 90, 1200, 0.10f});
                }
                else if (seq_name == "surprised_look") {
                    // Jolt back
                    steps->push_back({90, 115, 90, 150, 0.3f});  
                    steps->push_back({90, 115, 95, 800, 0.08f}); // Freeze
                    steps->push_back({90, 90, 90, 600, 0.15f});
                }
                else {
                    delete steps;
                    return ReturnValue("Unknown sequence");
                }

                ServoCommand cmd;
                cmd.type = GESTURE_CHOREOGRAPHY;
                cmd.sequence = steps;
                cmd.owns_sequence = true;
                
                xQueueSend(logic_queue_, &cmd, 0);
                return ReturnValue("Performing: " + seq_name);
            });

        // --- 2. GET POSITION TOOL ---
        mcp.AddTool("self.get_position",
            "Get current servo angles",
            PropertyList(),
            [this](const PropertyList& props) -> ReturnValue {
                char buf[64];
                snprintf(buf, sizeof(buf), "Pan:%.0f, Tilt:%.0f, Roll:%.0f", 
                    pan_servo_.current_pos, tilt_servo_.current_pos, roll_servo_.current_pos);
                return ReturnValue(std::string(buf));
            });

        // --- 3. BASIC MOVEMENT TOOL ---
        mcp.AddTool("self.move_head",
            "Move head. Direction: left, right, up, down, center. Intensity: 0-100",
            PropertyList({
                Property("direction", kPropertyTypeString, std::string("center")),
                Property("intensity", kPropertyTypeInteger, 70, 0, 100)
            }),
            [this](const PropertyList& props) -> ReturnValue {
                std::string dir = props["direction"].value<std::string>();
                int val = props["intensity"].value<int>();
                float intensity = (float)val / 100.0f;
                
                float t_pan = 90;
                float t_tilt = 90;
                float t_roll = 90;
                
                if (dir == "left") t_pan = 90 + (40 * intensity);
                else if (dir == "right") t_pan = 90 - (40 * intensity);
                else if (dir == "up") t_tilt = 90 + (30 * intensity);
                else if (dir == "down") t_tilt = 90 - (30 * intensity);
                
                ServoCommand cmd;
                cmd.type = GESTURE_LOOK_TARGET;
                cmd.param1 = t_pan;
                cmd.param2 = t_tilt;
                cmd.param3 = t_roll;
                xQueueSend(logic_queue_, &cmd, 0);

                return ReturnValue("Moving " + dir);
            });
    }

    virtual Led *GetLed() override { static NoOpLed led; return &led; }
    virtual Backlight *GetBacklight() override { static PwmBacklight b(DISPLAY_BACKLIGHT_PIN, DISPLAY_BACKLIGHT_OUTPUT_INVERT); return &b; }
    
    // --- BOILERPLATE ---
    void InitializeSpi() {
        spi_bus_config_t buscfg = {};
        buscfg.mosi_io_num = DISPLAY_MOSI_PIN;
        buscfg.miso_io_num = DISPLAY_MIS0_PIN;
        buscfg.sclk_io_num = DISPLAY_SCK_PIN;
        buscfg.quadwp_io_num = GPIO_NUM_NC;
        buscfg.quadhd_io_num = GPIO_NUM_NC;
        buscfg.max_transfer_sz = DISPLAY_WIDTH * DISPLAY_HEIGHT * sizeof(uint16_t);
        ESP_ERROR_CHECK(spi_bus_initialize(LCD_SPI_HOST, &buscfg, SPI_DMA_CH_AUTO));
    }

    void InitializeLcdDisplay() {
        esp_lcd_panel_io_handle_t panel_io = nullptr;
        esp_lcd_panel_handle_t panel = nullptr;
        esp_lcd_panel_io_spi_config_t io_config = {};
        io_config.cs_gpio_num = DISPLAY_CS_PIN;
        io_config.dc_gpio_num = DISPLAY_DC_PIN;
        io_config.spi_mode = DISPLAY_SPI_MODE;
        io_config.pclk_hz = DISPLAY_SPI_SCLK_HZ;
        io_config.trans_queue_depth = 10;
        io_config.lcd_cmd_bits = 8;
        io_config.lcd_param_bits = 8;
        ESP_ERROR_CHECK(esp_lcd_new_panel_io_spi(LCD_SPI_HOST, &io_config, &panel_io));
        
        esp_lcd_panel_dev_config_t panel_config = {};
        panel_config.reset_gpio_num = DISPLAY_RST_PIN;
        panel_config.rgb_ele_order = DISPLAY_RGB_ORDER;
        panel_config.bits_per_pixel = 16;
        ESP_ERROR_CHECK(esp_lcd_new_panel_ili9341(panel_io, &panel_config, &panel));
        esp_lcd_panel_reset(panel);
        esp_lcd_panel_init(panel);
        esp_lcd_panel_invert_color(panel, DISPLAY_INVERT_COLOR);
        esp_lcd_panel_swap_xy(panel, DISPLAY_SWAP_XY);
        esp_lcd_panel_mirror(panel, DISPLAY_MIRROR_X, DISPLAY_MIRROR_Y);
        
        display_ = new SpiLcdDisplay(panel_io, panel, 
            DISPLAY_WIDTH, DISPLAY_HEIGHT, DISPLAY_OFFSET_X, DISPLAY_OFFSET_Y, 
            DISPLAY_MIRROR_X, DISPLAY_MIRROR_Y, DISPLAY_SWAP_XY);
    }

    void InitializeI2c() {
        i2c_master_bus_config_t i2c_bus_cfg = {
            .i2c_port = AUDIO_CODEC_I2C_NUM,
            .sda_io_num = AUDIO_CODEC_I2C_SDA_PIN,
            .scl_io_num = AUDIO_CODEC_I2C_SCL_PIN,
            .clk_source = I2C_CLK_SRC_DEFAULT,
            .glitch_ignore_cnt = 7,
            .intr_priority = 0,
            .trans_queue_depth = 0,
            .flags = { .enable_internal_pullup = 1 },
        };
        ESP_ERROR_CHECK(i2c_new_master_bus(&i2c_bus_cfg, &codec_i2c_bus_));
    }

    void InitializeButtons() {
        boot_button_.OnClick([this]() {
            auto &app = Application::GetInstance();
            if (app.GetDeviceState() == kDeviceStateStarting && !WifiStation::GetInstance().IsConnected()) {
                ResetWifiConfiguration();
            }
            app.ToggleChatState();
        });
    }

    virtual AudioCodec* GetAudioCodec() override {
        static Es8311AudioCodec audio_codec(codec_i2c_bus_, AUDIO_CODEC_I2C_NUM,
            AUDIO_INPUT_SAMPLE_RATE, AUDIO_OUTPUT_SAMPLE_RATE, AUDIO_I2S_GPIO_MCLK, 
            AUDIO_I2S_GPIO_BCLK, AUDIO_I2S_GPIO_WS, AUDIO_I2S_GPIO_DOUT, 
            AUDIO_I2S_GPIO_DIN, AUDIO_CODEC_PA_PIN, AUDIO_CODEC_ES8311_ADDR, 
            true, true);
        return &audio_codec;
    }
    
    virtual Display *GetDisplay() override { return display_; }
};

DECLARE_BOARD(FreenoveESP32S3Display);